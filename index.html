<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lysterfield Sailing Club Results</title>
    <style>
        /* CSS Styles (Existing styles merged with additions for boat list) */
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f8ff;
        }
        h1, h2, h3 {
            color: #003366;
        }
        h4 { /* Style for Race N headers */
             color: #003366;
             margin-top: 15px;
             margin-bottom: 5px;
             border-bottom: 1px solid #ccc;
             padding-bottom: 3px;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box; /* Important for width: 100% */
        }
        /* Allow inputs/selects in specific containers to be auto width */
        .filter-group select, .filter-group input,
        .series-select select, .series-select input,
        .short-course-race-entry select, .short-course-race-entry input { /* Added short course */
            width: auto;
            padding: 4px 6px; /* Smaller padding for table inputs */
            font-size: 13px; /* Slightly smaller font */
        }
         /* Make time inputs wider in short course table */
        .short-course-race-entry input[type="text"] {
             min-width: 80px;
         }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .checkbox-group input[type="checkbox"] { /* Target only checkboxes */
            width: auto;
            margin-right: 8px;
        }
        .checkbox-group label {
            display: inline;
            margin-bottom: 0;
            font-weight: normal; /* Normal weight for checkbox labels */
        }
        button {
            background-color: #003366;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 5px; /* Add bottom margin for wrapping */
        }
        button:hover {
            background-color: #004080;
        }
        .btn-secondary { background-color: #4682B4; }
        .btn-secondary:hover { background-color: #5891c4; }
        .btn-warning { background-color: #ff9800; }
        .btn-warning:hover { background-color: #e68a00; }
        .btn-danger { background-color: #dc3545; }
        .btn-danger:hover { background-color: #c82333; }
        .btn-edit { background-color: #28a745; }
        .btn-edit:hover { background-color: #218838; }
        .btn-save { background-color: #17a2b8; }
        .btn-save:hover { background-color: #138496; }
        .btn-create-race { background-color: #ff9800; } /* Orange for Create Race */
        .btn-create-race:hover { background-color: #e68a00; }

        /* Results Styling */
        .results-table, #boat-list-table, #entries-table, .short-course-race-table { /* Apply common table styles */
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
        }
        .results-table th, #boat-list-table th, #entries-table th, .short-course-race-table th {
            background-color: #003366;
            color: white;
            text-align: left;
            padding: 6px 8px;
            font-weight: bold;
        }
        .results-table td, #boat-list-table td, #entries-table td, .short-course-race-table td {
            padding: 4px 8px;
            border: 1px solid #ddd; /* Add border to all table cells */
            text-align: left;
            vertical-align: middle; /* Align content vertically */
        }
        .results-table tr:nth-child(even), #boat-list-table tr:nth-child(even),
        #entries-table tr:nth-child(even), .short-course-race-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .results-table tr:hover, #boat-list-table tr:hover,
        #entries-table tr:hover, .short-course-race-table tr:hover {
            background-color: #e8f4ff;
        }

        .race-info-panel {
            background-color: #f0f8ff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .race-info-panel h3 { margin-top: 0; margin-bottom: 5px; }
        .race-info-panel p { margin: 5px 0; }

        /* Removed colour rules */

        .discarded { text-decoration: line-through; color: #888; font-style: italic; }
        .legend { font-size: 12px; margin-top: 15px; border-top: 1px solid #ddd; padding-top: 10px; }
        .legend span { margin-right: 5px; display: inline-block; }
        .legend strong { margin-right: 10px; }
        .legend .discarded-example { text-decoration: line-through; font-style: italic; color: #888; }

        .actions { display: flex; gap: 5px; flex-wrap: wrap; align-items: center; } /* Added align-items */
        .actions button { margin-right: 0; margin-bottom: 0; padding: 3px 6px; font-size: 10px; } /* Removed bottom margin */

        .entry-form, #boat-list-form /* Apply style to both forms */ {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .status-option { display: flex; align-items: center; margin: 10px 0; }
        /* Make radio buttons smaller and aligned */
        .status-option input[type="radio"] {
             width: auto;
             margin-right: 8px;
             padding: 0; /* Remove default padding */
             vertical-align: middle; /* Align with label text */
        }
        .status-option label {
            display: inline; /* Allow label next to radio */
            margin-bottom: 0; /* Remove block spacing */
            font-weight: normal; /* Normal weight */
             vertical-align: middle; /* Align with radio button */
        }
        .entry-buttons { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .result-highlight { background-color: #fffce8 !important; }
        .tab-buttons { margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 5px; }
        .tab-buttons button { margin-right: 0; }
        .tab-content { display: none; }
        .active-tab { display: block; }
        .active-button { background-color: #0056b3; }
        .race-card { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9; }
        .race-card h3 { margin-top: 0; }
        .race-info { display: flex; justify-content: space-between; margin-bottom: 10px; flex-wrap: wrap; }
        .race-actions { margin-top: 10px; }
        .series-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        .series-select { margin-bottom: 20px; }
        .series-date { margin-top: 10px; }
        .edit-result-form { margin-top: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 4px; background-color: #f8f9fa; }
        .edit-mode-warning { background-color: #fff3cd; padding: 10px; border-radius: 4px; margin-bottom: 15px; border: 1px solid #ffeeba; color: #856404; }
        .race-view-container { margin-top: 15px; }
        .race-selector { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .race-selector button { padding: 5px 10px; font-size: 12px; }
        .race-button { background-color: #f2f2f2; color: #333; border: 1px solid #ddd; }
        .race-button.active { background-color: #003366; color: white; }
        .race-button.has-results { border: 2px solid #28a745; }
        #results-table th:last-child, #results-table td:last-child { width: auto; min-width: 50px; text-align: center; } /* Actions col */
        #boat-list-table th:last-child, #boat-list-table td:last-child { width: auto; min-width: 100px; text-align: center; } /* Actions col for boat list */
        #entries-table th:last-child, #entries-table td:last-child { width: auto; min-width: 100px; text-align: center; } /* Actions col for entries */
        .short-course-race-table th:nth-child(5), .short-course-race-table td:nth-child(5) { width: 120px; } /* Status Col Width */
        .short-course-race-table th:nth-child(6), .short-course-race-table td:nth-child(6) { width: 100px; } /* Time Col Width */
        .short-course-race-table th:last-child, .short-course-race-table td:last-child { width: auto; min-width: 60px; text-align: center; } /* Actions Col Width */

        .series-results-table td, .series-results-table th { white-space: nowrap; }
        .series-results-table .nr-cell { color: #999; font-style: italic; text-align: center; }
        .action-buttons { display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0; }
        .action-buttons button { margin-right: 0; }
        /* Specific styling for saved boat dropdown */
        #saved-boat-selector { margin-bottom: 20px; /* Optional: Adjust spacing */ }
        #saved-boat-selector label { margin-bottom: 8px; }
        .hidden { display: none !important; } /* Utility class */

        /* Container for short course created races */
        #short-course-races-container {
            margin-top: 25px;
            border-top: 2px solid #003366;
            padding-top: 15px;
        }
        .short-course-race-section {
             border: 1px solid #ccc;
             border-radius: 5px;
             padding: 10px 15px;
             margin-bottom: 15px;
             background-color: #f9f9f9;
        }
        .short-course-race-section h4 { margin-top: 0; } /* Reset top margin for section header */

    </style>
</head>
<body>
    <div class="container">
        <h1>Lysterfield Results App</h1>

        <div class="tab-buttons">
            <button id="btn-series" class="active-button">Series Management</button>
            <button id="btn-boat-list">Boat List</button>
            <button id="btn-race">Race Entry</button>
            <button id="btn-results">Race Results</button>
            <button id="btn-series-results">Series Results</button>
            <button id="btn-race-view">Race Viewer</button>
        </div>

        <!-- Series Management Tab -->
        <div id="series-tab" class="tab-content active-tab">
            <div class="series-header"><h2>Series Management</h2><button id="create-series-btn">Create New Series</button></div>
            <!-- Series Create/Edit Form -->
            <div id="create-series-form" class="entry-form hidden"> <!-- Start hidden -->
                <h3>Create/Edit Series</h3>
                <div class="form-group">
                    <label for="series-name">Series Name:</label>
                    <input type="text" id="series-name" placeholder="e.g., Summer Series 2024">
                </div>
                <!-- ========== START: SHORT COURSE CHECKBOX ========== -->
                <div class="checkbox-group">
                    <input type="checkbox" id="series-short-course">
                    <label for="series-short-course">This is a Short Course Series (Races created dynamically)</label>
                </div>
                <!-- ========== END: SHORT COURSE CHECKBOX ========== -->
                <div id="standard-series-options"> <!-- Wrapper for options hidden in short course -->
                    <div class="form-group">
                        <label for="number-of-races">Number of Races Planned:</label>
                        <input type="number" id="number-of-races" min="1" max="50" value="8">
                    </div>
                    <div class="form-group">
                        <label for="races-per-discard">Discard 1 race after how many completed races? (Enter 0 for no discards)</label>
                        <input type="number" id="races-per-discard" min="0" max="20" value="4">
                        <small>Example: If set to 5, 1 discard applies after race 5, 2 discards after race 10, etc.</small>
                    </div>
                </div>
                 <!-- DNC rule applies to both types -->
                <div class="form-group">
                    <label>DNC Points Calculation:</label>
                    <div class="status-option">
                        <input type="radio" id="dnc-rule-race" name="dnc-scoring-rule" value="raceEntries" checked>
                        <label for="dnc-rule-race">Entries in specific Race + 1</label>
                    </div>
                    <div class="status-option">
                        <input type="radio" id="dnc-rule-series" name="dnc-scoring-rule" value="seriesCompetitors">
                        <label for="dnc-rule-series">Total unique competitors in Series + 1</label>
                    </div>
                </div>

                <input type="hidden" id="edit-series-id">
                <div class="entry-buttons">
                    <button id="save-series-btn">Save Series</button>
                    <button id="cancel-series-btn" class="btn-secondary">Cancel</button>
                </div>
            </div>
            <!-- Series List Display -->
            <div id="series-list">
                <!-- Series cards will be generated here -->
            </div>

            <div class="action-buttons" style="margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px;">
                <h3>Data Management</h3>
                <button id="export-all-data-btn" class="btn-secondary">Export All Data (Series & Boats)</button>
                <button id="import-data-btn" class="btn-warning">Import Data (Replaces Current)</button>
                <input type="file" id="import-file-input" accept=".json" style="display: none;">
                <p style="font-size: 12px; color: #666; margin-top: 5px;">
                    Export creates a JSON backup of all series, races, results, and the saved boat list.
                    Import will <strong>replace</strong> all current data with the data from the selected file. Use with caution.
                </p>
            </div>

        </div> <!-- End of series-tab -->


        <!-- Boat List Tab -->
        <div id="boat-list-tab" class="tab-content">
             <div class="series-header">
                <h2>Manage Boat List</h2>
                <button id="show-add-boat-form-btn">Add New Boat</button>
            </div>
             <div id="boat-list-form" class="entry-form hidden"> <!-- Start hidden -->
                 <h3 id="boat-form-title">Add New Boat</h3>
                 <div class="form-group">
                     <label for="boat-sail-number">Sail Number:</label>
                     <input type="text" id="boat-sail-number" placeholder="e.g., AUS123 (Must be unique)">
                 </div>
                  <div class="form-group">
                     <label for="boat-class-list">Default Boat Class:</label>
                     <select id="boat-class-list">
                         <option value="">Select boat class</option>
                         <!-- Populated from yardstick data -->
                     </select>
                 </div>
                 <div class="checkbox-group">
                     <input type="checkbox" id="boat-manual-class-check">
                     <label for="boat-manual-class-check">Enter boat class manually</label>
                 </div>
                 <div id="boat-manual-class-input" class="form-group hidden"> <!-- Use class -->
                     <label for="boat-manual-boat-class">Custom Boat Class:</label>
                     <input type="text" id="boat-manual-boat-class" placeholder="Enter custom boat class">
                 </div>
                  <div class="form-group">
                     <label for="boat-skipper">Default Skipper Name:</label>
                     <input type="text" id="boat-skipper" placeholder="Full name">
                 </div>
                  <div class="form-group">
                     <label for="boat-yardstick">Default Yardstick:</label>
                     <input type="number" id="boat-yardstick" step="0.1" placeholder="Auto-filled or enter manually">
                 </div>
                  <div class="checkbox-group">
                     <input type="checkbox" id="boat-manual-yardstick-check">
                     <label for="boat-manual-yardstick-check">Enter yardstick manually</label>
                 </div>
                 <input type="hidden" id="editing-boat-id" value="">
                 <div class="entry-buttons">
                     <button id="save-boat-list-btn">Save Boat</button>
                     <button id="cancel-boat-list-btn" class="btn-secondary">Cancel</button>
                 </div>
             </div>
             <h3>Saved Boats</h3>
              <div style="overflow-x: auto;">
                 <table id="boat-list-table">
                     <thead>
                         <tr>
                             <th>Sail #</th>
                             <th>Boat Class</th>
                             <th>Skipper</th>
                             <th>Yardstick</th>
                             <th>Actions</th>
                         </tr>
                     </thead>
                     <tbody id="boat-list-body"></tbody>
                 </table>
             </div>

              <div class="action-buttons" style="margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px;">
                 <h3>Boat List Data Management</h3>
                 <button id="export-boat-list-btn" class="btn-secondary">Export Boat List Only</button>
                 <button id="import-boat-list-btn" class="btn-warning">Import Boat List (Replaces Current)</button>
                 <input type="file" id="import-boat-list-file-input" accept=".json" style="display: none;">
                 <p style="font-size: 12px; color: #666; margin-top: 5px;">
                     Export creates a JSON backup of the current saved boat list.
                     Import will <strong>replace</strong> the current boat list with the data from the selected file. Series data is unaffected.
                 </p>
             </div>
        </div> <!-- End of boat-list-tab -->

        <!-- Race Entry Tab (MODIFIED for Short Course) -->
        <div id="race-tab" class="tab-content">
            <h2>Race Entry</h2>

           <div class="series-select">
                <label for="select-series">Select Series:</label>
                <select id="select-series"></select>
                 <!-- ========== MODIFIED: Race selector wrapper (hidden for short course) ========== -->
                <span id="race-selector-wrapper">
                    <label for="select-race" style="margin-left: 15px;">Select Race Number:</label>
                    <select id="select-race"></select>
                </span>
                 <!-- ========== END MODIFICATION ========== -->
            </div>

            <div id="edit-mode-warning" class="edit-mode-warning hidden"></div>

            <!-- Entry Form -->
            <div class="entry-form">
                <h3 id="entry-form-title">Add/Edit Boat Entry</h3>

                <div id="saved-boat-selector" class="form-group">
                    <label for="select-saved-boat">Select Saved Boat (Optional):</label>
                    <select id="select-saved-boat">
                        <option value="">-- Select Saved Boat --</option>
                        <!-- Populated from boatList -->
                    </select>
                    <small>Selecting a boat will pre-fill the details below. You can still modify them.</small>
                </div>

                <div class="form-group"><label for="sail-number">Sail Number:</label><input type="text" id="sail-number" placeholder="e.g. AUS123"></div>
                <div class="form-group"><label for="boat-class">Boat Class:</label><select id="boat-class"><option value="">Select boat class</option></select></div>
                <div class="checkbox-group"><input type="checkbox" id="manual-class-check"><label for="manual-class-check">Enter boat class manually</label></div>
                <div id="manual-class-input" class="form-group hidden"><label for="manual-boat-class">Custom Boat Class:</label><input type="text" id="manual-boat-class"></div>
                <div class="form-group"><label for="skipper">Skipper Name:</label><input type="text" id="skipper" placeholder="Full name"></div>
                <div class="form-group"><label for="yardstick">Yardstick (PN):</label><input type="number" id="yardstick" step="0.1" placeholder="Auto-filled or enter manually"></div>
                <div class="checkbox-group"><input type="checkbox" id="manual-yardstick-check"><label for="manual-yardstick-check">Enter yardstick manually</label></div>

                <!-- ========== MODIFIED: Status and Time inputs wrapper (hidden for short course entry) ========== -->
                <div id="standard-entry-fields">
                    <div class="form-group"><label>Race Status:</label><!-- Status Radio Buttons -->
                        <div class="status-option"><input type="radio" id="status-finished" name="race-status" value="finished" checked><label for="status-finished">Finished</label></div>
                        <div class="status-option"><input type="radio" id="status-dnf" name="race-status" value="DNF"><label for="status-dnf">DNF</label></div>
                        <div class="status-option"><input type="radio" id="status-dns" name="race-status" value="DNS"><label for="status-dns">DNS</label></div>
                        <div class="status-option"><input type="radio" id="status-ocs" name="race-status" value="OCS"><label for="status-ocs">OCS</label></div>
                        <div class="status-option"><input type="radio" id="status-dsq" name="race-status" value="DSQ"><label for="status-dsq">DSQ</label></div>
                        <div class="status-option"><input type="radio" id="status-ood" name="race-status" value="OOD"><label for="status-ood">OOD</label></div>
                    </div>
                    <div id="time-inputs" class="form-group"><label for="elapsed-time">Elapsed Time (hh:mm:ss):</label><input type="text" id="elapsed-time" placeholder="e.g. 01:30:45"></div>
                </div>
                <!-- ========== END MODIFICATION ========== -->

                <div class="entry-buttons">
                    <button id="add-boat">Add Boat</button> <!-- Text changes dynamically -->
                    <button id="update-boat" class="btn-edit hidden">Update Boat</button>
                    <button id="cancel-update" class="btn-secondary hidden">Cancel Update</button>
                    <button id="clear-form" class="btn-secondary">Clear Form</button>
                </div>
                <input type="hidden" id="editing-entry-index" value="-1">
                 <!-- Hidden input to track editing within a short course race -->
                <input type="hidden" id="editing-short-course-race-index" value="-1">
            </div>

             <!-- ========== STANDARD ENTRIES DISPLAY (Hidden for Short Course) ========== -->
            <div id="standard-entries-display">
                <h3 id="current-entries-heading">Current Entries for Selected Race</h3>
                <div style="overflow-x: auto;">
                    <table id="entries-table">
                        <thead><tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Status</th><th>Elapsed Time</th><th>Actions</th></tr></thead>
                        <tbody id="entries-body"></tbody>
                    </table>
                </div>
            </div>
            <!-- ========== END STANDARD ========== -->

             <!-- ========== SHORT COURSE STAGING AREA (Shown for Short Course) ========== -->
            <div id="short-course-staging-display" class="hidden">
                <h3 id="short-course-pool-heading">Next Race Pool (Add/Remove Boats Here)</h3>
                 <div style="overflow-x: auto;">
                     <table id="short-course-pool-table" class="results-table"> <!-- Use results-table style -->
                         <thead><tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Actions</th></tr></thead>
                         <tbody id="short-course-pool-body"></tbody>
                     </table>
                 </div>
                 <div class="action-buttons">
                     <button id="create-short-course-race-btn" class="btn-create-race">Create Race 1</button>
                 </div>
            </div>
            <!-- ========== END SHORT COURSE STAGING ========== -->

             <!-- ========== SHORT COURSE CREATED RACES CONTAINER ========== -->
             <div id="short-course-races-container" class="hidden">
                 <h3>Created Races (This Session)</h3>
                 <!-- Race N sections will be appended here by JS -->
             </div>
             <!-- ========== END SHORT COURSE CREATED RACES ========== -->


            <div style="margin-top: 20px;" class="action-buttons">
                <button id="calculate-results">Calculate Race Results & View</button>
                <button id="clear-all" class="btn-warning">Clear Current List/Pool</button>
                <!-- ========== ADDED: Clear Short Course Races Button ========== -->
                <button id="clear-short-course-session-btn" class="btn-danger hidden">Clear Created Races</button>
                <!-- ========== END ADDITION ========== -->
            </div>
        </div>


        <!-- Race Results Tab -->
        <div id="results-tab" class="tab-content">
             <h2>Race Results</h2>
             <div class="series-select"><label for="results-series-select">Series:</label><select id="results-series-select"></select><label for="results-race-select">Race:</label><select id="results-race-select"></select></div>
             <div id="result-race-info"></div>
             <div class="action-buttons"><button id="save-results-tab-btn" class="btn-save">Save These Results to Series</button><button id="edit-race-entries" class="btn-edit">Edit Race Entries</button><button id="edit-results-directly" class="btn-warning">Direct Edit</button></div>
             <div id="direct-edit-warning" class="edit-mode-warning hidden"></div>
             <div style="overflow-x: auto;"><table id="results-table" class="results-table"><thead><tr><th>Pos</th><th>Sail No</th><th>Boat Type</th><th>Helm</th><th>YS</th><th>Finish</th><th>Elapsed</th><th>Corrected</th><th>Points</th><th>Actions</th></tr></thead><tbody id="results-body"></tbody></table></div>
             <div id="edit-result-form" class="edit-result-form hidden"><h3>Edit Result (Directly)</h3><p>Editing: <strong id="edit-result-label"></strong></p><!-- Direct Edit Fields -->
                <div class="form-group"><label for="edit-status-direct">Status:</label><select id="edit-status-direct"></select></div>
                <div id="edit-time-inputs-direct" class="form-group"><label for="edit-elapsed-time-direct">Elapsed Time:</label><input type="text" id="edit-elapsed-time-direct" placeholder="hh:mm:ss"></div>
                <div class="form-group"><label for="edit-position-direct">Position:</label><input type="text" id="edit-position-direct" placeholder="e.g., 3 or DNF"></div>
                <div class="form-group"><label for="edit-points-direct">Points:</label><input type="number" step="0.1" id="edit-points-direct"></div>
                <input type="hidden" id="edit-result-index">
                <div class="entry-buttons"><button id="save-edit-result">Update Displayed Result</button><button id="cancel-edit-result" class="btn-secondary">Cancel</button></div>
             </div>
        </div>

        <!-- Series Results Tab -->
        <div id="series-results-tab" class="tab-content">
             <h2>Series Results</h2>
             <div class="series-select"><label for="view-series-select">Select Series:</label><select id="view-series-select"></select></div>
             <div id="series-summary"></div>
             <div style="overflow-x: auto;"><table id="series-results-table" class="results-table series-results-table"><thead id="series-results-header"></thead><tbody id="series-results-body"></tbody></table></div>
             <div class="legend"><strong>Legend:</strong><!-- Populated by JS --></div>
        </div>

        <!-- Race Viewer Tab -->
        <div id="race-view-tab" class="tab-content">
             <h2>Race Viewer</h2>
             <div class="series-select"><label for="view-all-series-select">Select Series:</label><select id="view-all-series-select"></select></div>
             <div id="race-summary-view"></div>
             <div class="race-selector"></div>
             <div class="race-view-container"><div id="individual-race-info"></div><div style="overflow-x: auto;"><table id="individual-race-results" class="results-table"><thead><!-- Set by JS --></thead><tbody id="individual-race-body"></tbody></table></div></div>
        </div>

    </div>

    <script>
        // Yardstick data (still needed for dropdowns)
        const yardstickData = [
            { boatClass: "125", yardstick: 123 }, { boatClass: "145", yardstick: 113 }, { boatClass: "29er", yardstick: 95 }, { boatClass: "420", yardstick: 112 }, { boatClass: "470", yardstick: 101 },
            { boatClass: "505", yardstick: 93 }, { boatClass: "B14", yardstick: 94 }, { boatClass: "Byte", yardstick: 125.4 }, { boatClass: "Byte CII", yardstick: 120.4 }, { boatClass: "Cherub", yardstick: 100 },
            { boatClass: "Contender", yardstick: 106.5 }, { boatClass: "Corsair", yardstick: 119.5 }, { boatClass: "E Class (Lazy E)", yardstick: 113 }, { boatClass: "Europe Dinghy", yardstick: 120 },
            { boatClass: "Fireball", yardstick: 101 }, { boatClass: "Finn", yardstick: 110 }, { boatClass: "Flying Ant", yardstick: 135 }, { boatClass: "Flying 11", yardstick: 117 }, { boatClass: "Heron", yardstick: 134 },
            { boatClass: "Impulse", yardstick: 118.5 }, { boatClass: "Impulse 6.6", yardstick: 124.5 }, { boatClass: "Javelin", yardstick: 97.5 }, { boatClass: "Jubilee", yardstick: 130 }, { boatClass: "Laser", yardstick: 114 },
            { boatClass: "Laser Radial", yardstick: 118.5 }, { boatClass: "Laser 4.7", yardstick: 127 }, { boatClass: "Mirror", yardstick: 143 }, { boatClass: "Moth Skiff", yardstick: 60 }, { boatClass: "Moth Scow", yardstick: 115 },
            { boatClass: "NS14", yardstick: 108 }, { boatClass: "OK Dinghy", yardstick: 115.5 }, { boatClass: "Open Bic", yardstick: 153.3 }, { boatClass: "Optimist", yardstick: 170 }, { boatClass: "Pacer", yardstick: 127.5 },
            { boatClass: "Pacer Non Spinnaker", yardstick: 130.4}, { boatClass: "RS 100 8.4", yardstick: 106 }, { boatClass: "RS 100 10.2", yardstick: 103 }, { boatClass: "RS 200", yardstick: 108.5 }, { boatClass: "RS 300", yardstick: 103.4 },
            { boatClass: "RS 400", yardstick: 96.6 }, { boatClass: "RS 500", yardstick: 102.7 }, { boatClass: "RS 600", yardstick: 87.2 }, { boatClass: "RS 700", yardstick: 83.8 }, { boatClass: "RS 800", yardstick: 86.3 },
            { boatClass: "RS Aero 5", yardstick: 116.8 }, { boatClass: "RS Aero 6", yardstick: 114.6 }, { boatClass: "RS Aero 7", yardstick: 112.5 }, { boatClass: "RS Aero 9", yardstick: 108 }, { boatClass: "RS Feva XL", yardstick: 130 },
            { boatClass: "RS Tera Pro", yardstick: 143.2 }, { boatClass: "RS Tera Sport", yardstick: 153.9 }, { boatClass: "RS Vareo", yardstick: 113.1 }, { boatClass: "RS Vision", yardstick: 123.7 }, { boatClass: "Sabre", yardstick: 127 },
            { boatClass: "Sailfish", yardstick: 132 }, { boatClass: "Sparrow", yardstick: 145 }, { boatClass: "Solo", yardstick: 123.5 }, { boatClass: "Sabot", yardstick: 160.5 }, { boatClass: "Sharpie", yardstick: 95 },
            { boatClass: "Spiral", yardstick: 124 }, { boatClass: "Tasar", yardstick: 108 },
        ];

        // --- App State ---
        let entries = []; // Holds entries for standard races OR the "pool" for short courses
        let results = []; // Holds calculated results for display on Results tab
        let series = []; // Holds all series data
        let boatList = []; // Holds saved boat data
        let shortCourseSessionRaces = []; // Holds {raceNumber, entries:[{..., status, elapsedTime}]} for short course races created *this session*
        let currentSeries = null;
        let currentRace = null; // Race number for standard series
        let editMode = false; // For standard races, loading saved data
        let directEditMode = false;
        let resultBeingEdited = null; // Store original state for direct edit cancel

        // --- DOM Elements ---
        // Tabs & Buttons
        const seriesTab = document.getElementById('series-tab');
        const raceTab = document.getElementById('race-tab');
        const resultsTab = document.getElementById('results-tab');
        const seriesResultsTab = document.getElementById('series-results-tab');
        const raceViewTab = document.getElementById('race-view-tab');
        const boatListTab = document.getElementById('boat-list-tab');
        const btnSeries = document.getElementById('btn-series');
        const btnRace = document.getElementById('btn-race');
        const btnResults = document.getElementById('btn-results');
        const btnSeriesResults = document.getElementById('btn-series-results');
        const btnRaceView = document.getElementById('btn-race-view');
        const btnBoatList = document.getElementById('btn-boat-list');

        // Race Entry Form Elements
        const entryFormTitle = document.getElementById('entry-form-title');
        const sailNumber = document.getElementById('sail-number');
        const boatClassSelect = document.getElementById('boat-class');
        const skipperName = document.getElementById('skipper');
        const yardstickValue = document.getElementById('yardstick');
        const elapsedTime = document.getElementById('elapsed-time');
        const timeInputs = document.getElementById('time-inputs');
        const statusRadios = document.querySelectorAll('input[name="race-status"]');
        const manualClassCheck = document.getElementById('manual-class-check');
        const manualClassInput = document.getElementById('manual-class-input');
        const manualBoatClass = document.getElementById('manual-boat-class');
        const manualYardstickCheck = document.getElementById('manual-yardstick-check');
        const addBoatBtn = document.getElementById('add-boat');
        const updateBoatBtn = document.getElementById('update-boat');
        const cancelUpdateBtn = document.getElementById('cancel-update');
        const clearFormBtn = document.getElementById('clear-form');
        const editingEntryIndexInput = document.getElementById('editing-entry-index');
        const editingShortCourseRaceIndexInput = document.getElementById('editing-short-course-race-index'); // For editing within short course race
        const entriesBody = document.getElementById('entries-body'); // Standard entries table body
        const calculateResultsBtn = document.getElementById('calculate-results');
        const clearAllBtn = document.getElementById('clear-all');
        const editModeWarning = document.getElementById('edit-mode-warning');
        const selectSavedBoat = document.getElementById('select-saved-boat');
        const standardEntryFields = document.getElementById('standard-entry-fields'); // Wrapper for status/time
        const raceSelectorWrapper = document.getElementById('race-selector-wrapper'); // Wrapper for race dropdown label/select

        // Standard Race UI Elements
        const standardEntriesDisplay = document.getElementById('standard-entries-display');
        const currentEntriesHeading = document.getElementById('current-entries-heading');

        // Short Course UI Elements
        const shortCourseStagingDisplay = document.getElementById('short-course-staging-display');
        const shortCoursePoolHeading = document.getElementById('short-course-pool-heading');
        const shortCoursePoolBody = document.getElementById('short-course-pool-body');
        const createShortCourseRaceBtn = document.getElementById('create-short-course-race-btn');
        const shortCourseRacesContainer = document.getElementById('short-course-races-container');
        const clearShortCourseSessionBtn = document.getElementById('clear-short-course-session-btn');

        // Series/Race Selection Dropdowns
        const selectSeries = document.getElementById('select-series');
        const selectRace = document.getElementById('select-race');
        const resultsSeries = document.getElementById('results-series-select');
        const resultsRace = document.getElementById('results-race-select');
        const viewSeries = document.getElementById('view-series-select');
        const viewAllSeries = document.getElementById('view-all-series-select');

        // Results Tab Elements
        const resultsBody = document.getElementById('results-body');
        const resultRaceInfo = document.getElementById('result-race-info');
        const saveResultsTabBtn = document.getElementById('save-results-tab-btn');
        const editRaceEntriesBtn = document.getElementById('edit-race-entries');
        const editResultsDirectlyBtn = document.getElementById('edit-results-directly');
        const directEditWarning = document.getElementById('direct-edit-warning');

        // Series Results Tab Elements
        const seriesResultsBody = document.getElementById('series-results-body');
        const seriesResultsHeader = document.getElementById('series-results-header');
        const seriesSummary = document.getElementById('series-summary');
        const legendDiv = document.querySelector('.legend');

        // Race Viewer Tab Elements
        const raceSummaryView = document.getElementById('race-summary-view');
        const raceSelector = document.querySelector('.race-selector');
        const individualRaceInfo = document.getElementById('individual-race-info');
        const individualRaceBody = document.getElementById('individual-race-body');
        const individualRaceHeader = document.querySelector('#individual-race-results thead');
        if (individualRaceHeader) {
            individualRaceHeader.innerHTML = '<tr><th>Pos</th><th>Sail No</th><th>Boat Type</th><th>Helm</th><th>YS</th><th>Finish</th><th>Elapsed</th><th>Corrected</th><th>Points</th></tr>';
        }

        // Series Management Form Elements
        const createSeriesBtn = document.getElementById('create-series-btn');
        const saveSeriesBtn = document.getElementById('save-series-btn');
        const cancelSeriesBtn = document.getElementById('cancel-series-btn');
        const seriesName = document.getElementById('series-name');
        const seriesShortCourseCheck = document.getElementById('series-short-course'); // Short Course checkbox
        const standardSeriesOptions = document.getElementById('standard-series-options'); // Wrapper div
        const numberOfRaces = document.getElementById('number-of-races');
        const racesPerDiscardInput = document.getElementById('races-per-discard');
        const editSeriesId = document.getElementById('edit-series-id');
        const createSeriesForm = document.getElementById('create-series-form');
        const seriesList = document.getElementById('series-list');

        // Edit Result Form (Direct) Elements
        const editResultForm = document.getElementById('edit-result-form');
        const editResultLabel = document.getElementById('edit-result-label');
        const editStatusDirect = document.getElementById('edit-status-direct');
        const editTimeInputsDirect = document.getElementById('edit-time-inputs-direct');
        const editElapsedTimeDirect = document.getElementById('edit-elapsed-time-direct');
        const editPositionDirect = document.getElementById('edit-position-direct');
        const editPointsDirect = document.getElementById('edit-points-direct');
        const editResultIndex = document.getElementById('edit-result-index');
        const saveEditResult = document.getElementById('save-edit-result');
        const cancelEditResult = document.getElementById('cancel-edit-result');
         if (editStatusDirect && editStatusDirect.options.length === 0) {
             const statuses = ['finished', 'DNF', 'DNS', 'OCS', 'DSQ', 'OOD'];
             statuses.forEach(status => {
                 const option = document.createElement('option'); option.value = status; option.textContent = status.toUpperCase(); editStatusDirect.appendChild(option);
             });
         }

        // Boat List Tab Elements
        const showAddBoatFormBtn = document.getElementById('show-add-boat-form-btn');
        const boatListForm = document.getElementById('boat-list-form');
        const boatFormTitle = document.getElementById('boat-form-title');
        const boatSailNumber = document.getElementById('boat-sail-number');
        const boatClassList = document.getElementById('boat-class-list');
        const boatManualClassCheck = document.getElementById('boat-manual-class-check');
        const boatManualClassInput = document.getElementById('boat-manual-class-input');
        const boatManualBoatClass = document.getElementById('boat-manual-boat-class');
        const boatSkipper = document.getElementById('boat-skipper');
        const boatYardstick = document.getElementById('boat-yardstick');
        const boatManualYardstickCheck = document.getElementById('boat-manual-yardstick-check');
        const editingBoatId = document.getElementById('editing-boat-id');
        const saveBoatListBtn = document.getElementById('save-boat-list-btn');
        const cancelBoatListBtn = document.getElementById('cancel-boat-list-btn');
        const boatListTable = document.getElementById('boat-list-table');
        const boatListBody = document.getElementById('boat-list-body');

        // Export/Import Elements
        const exportAllDataBtn = document.getElementById('export-all-data-btn');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInput = document.getElementById('import-file-input');
        const exportBoatListBtn = document.getElementById('export-boat-list-btn');
        const importBoatListBtn = document.getElementById('import-boat-list-btn');
        const importBoatListFileInput = document.getElementById('import-boat-list-file-input');


        // --- Utility Functions ---
        function isValidTimeFormat(timeStr) { if (!timeStr) return false; const regex = /^([0-9]{1,2}):([0-5][0-9]):([0-5][0-9])$/; return regex.test(timeStr); }
        function timeToSeconds(timeStr) { if (!isValidTimeFormat(timeStr)) return 0; const [hours, minutes, seconds] = timeStr.split(':').map(Number); return hours * 3600 + minutes * 60 + seconds; }
        function secondsToTime(seconds) { if (isNaN(seconds) || seconds === null || seconds < 0) return ''; seconds = Math.round(seconds); const hours = Math.floor(seconds / 3600); let minutes = Math.floor((seconds % 3600) / 60); let secs = seconds % 60; if (secs === 60) { minutes += 1; secs = 0; } if (minutes === 60) { /* hours += 1; */ minutes = 0; } return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
        // Simple pluralize helper
        function pluralize(count, singular, plural = null) { return count === 1 ? singular : (plural || singular + 's'); }


        // --- Tab Navigation ---
        function setActiveTab(tabElement) {
             document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active-tab'));
             document.querySelectorAll('.tab-buttons button').forEach(btn => btn.classList.remove('active-button'));

             if (tabElement) {
                 tabElement.classList.add('active-tab');
                 const buttonId = 'btn-' + tabElement.id.replace('-tab', '');
                 const correspondingButton = document.getElementById(buttonId);
                 if(correspondingButton) { correspondingButton.classList.add('active-button'); }
                 else { console.warn("Could not find button for tab:", buttonId); }
             } else { console.error("setActiveTab called with null element"); }

             // Reset modes/warnings when switching tabs
             if (tabElement?.id !== 'results-tab') { disableDirectEditMode(); }
             if (tabElement?.id !== 'race-tab') {
                editMode = false;
                editModeWarning?.classList.add('hidden');
                // Clear short course session data if navigating away from Race Entry tab
                if (shortCourseSessionRaces.length > 0) {
                    console.log("Navigating away from Race Entry tab, clearing short course session.");
                    clearShortCourseSessionData();
                }
             }
             // Use hidden class consistently
             if (tabElement?.id !== 'boat-list-tab') { boatListForm?.classList.add('hidden'); }
             if (tabElement?.id !== 'series-tab') { createSeriesForm?.classList.add('hidden'); }

         }
        if(btnBoatList) btnBoatList.addEventListener('click', () => setActiveTab(boatListTab));
        if(btnSeries) btnSeries.addEventListener('click', () => setActiveTab(seriesTab));
        if(btnRace) btnRace.addEventListener('click', () => setActiveTab(raceTab));
        if(btnResults) btnResults.addEventListener('click', () => setActiveTab(resultsTab));
        if(btnSeriesResults) btnSeriesResults.addEventListener('click', () => { setActiveTab(seriesResultsTab); if (viewSeries?.value) calculateSeriesResults(); });
        if(btnRaceView) btnRaceView.addEventListener('click', () => { setActiveTab(raceViewTab); if (viewAllSeries?.value) displayRaceViewer(); });


        // --- Yardstick Functions ---
        function initYardsticks() {
            yardstickData.sort((a, b) => a.boatClass.localeCompare(b.boatClass));
            const populateSelect = (selectElement) => {
                 if (!selectElement) return;
                 selectElement.innerHTML = '<option value="">Select boat class</option>';
                 yardstickData.forEach(boat => {
                     const option = document.createElement('option');
                     option.value = boat.boatClass;
                     option.textContent = `${boat.boatClass} (${boat.yardstick})`;
                     selectElement.appendChild(option);
                 });
            }
            populateSelect(boatClassSelect); // Race entry
            populateSelect(boatClassList); // Boat list management
        }

        // --- Boat List Functions ---
        function renderBoatListTable() { /* ... remains unchanged ... */
            if (!boatListBody) return;
            boatListBody.innerHTML = '';
            boatList.sort((a, b) => a.sailNumber.localeCompare(b.sailNumber));

             if (boatList.length === 0) {
                  const row = boatListBody.insertRow();
                  const cell = row.insertCell(); cell.colSpan = 5;
                  cell.textContent = 'No boats saved yet. Click "Add New Boat" to start.';
                  cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666';
                  return;
             }

            boatList.forEach(boat => {
                const row = boatListBody.insertRow();
                row.innerHTML = `
                    <td>${boat.sailNumber}</td>
                    <td>${boat.boatClass}</td>
                    <td>${boat.skipper}</td>
                    <td>${boat.yardstick}</td>
                    <td class="actions">
                        <button class="btn-edit" onclick="editBoatInList(${boat.id})">Edit</button>
                        <button class="btn-danger" onclick="deleteBoatFromList(${boat.id})">Delete</button>
                    </td>
                `;
            });
            populateSavedBoatDropdown();
        }
        function clearBoatListForm() { /* ... remains unchanged ... */
            if (!boatListForm) return;
            if(boatSailNumber) boatSailNumber.value = '';
            if(boatClassList) boatClassList.value = '';
            if(boatSkipper) boatSkipper.value = '';
            if(boatYardstick) boatYardstick.value = '';
            if(boatManualBoatClass) boatManualBoatClass.value = '';
            if(editingBoatId) editingBoatId.value = '';
            if(boatManualClassCheck) boatManualClassCheck.checked = false;
            if(boatManualClassInput) boatManualClassInput.classList.add('hidden'); // Use class
            if(boatClassList) boatClassList.disabled = false;
            if(boatManualYardstickCheck) boatManualYardstickCheck.checked = false;
            if(boatYardstick) boatYardstick.readOnly = true;
            if(boatFormTitle) boatFormTitle.textContent = "Add New Boat";
            boatListForm.classList.add('hidden'); // Use hidden class
            if(boatClassList) boatClassList.dispatchEvent(new Event('change'));
        }
        if(showAddBoatFormBtn) showAddBoatFormBtn.addEventListener('click', () => { /* ... remains unchanged ... */
            clearBoatListForm();
            if(boatFormTitle) boatFormTitle.textContent = "Add New Boat";
            if(boatListForm) boatListForm.classList.remove('hidden'); // Use hidden class
            if(boatSailNumber) boatSailNumber.focus();
        });
        if(cancelBoatListBtn) cancelBoatListBtn.addEventListener('click', clearBoatListForm); /* ... remains unchanged ... */

        if(saveBoatListBtn) saveBoatListBtn.addEventListener('click', () => { /* ... ADDED LOGGING ... */
            console.log("Attempting to save boat..."); // Logging
            const id = editingBoatId?.value ? parseInt(editingBoatId.value) : null;
            const sailNum = boatSailNumber?.value.trim().toUpperCase(); // Ensure uppercase
            const skipper = boatSkipper?.value.trim();
            const yardstick = parseFloat(boatYardstick?.value);
            const isManualClass = boatManualClassCheck?.checked;
            const boatClass = isManualClass ? boatManualBoatClass?.value.trim() : boatClassList?.value;

            if (!sailNum) { alert("Sail Number is required."); return; }
            if (!boatClass) { alert("Boat Class is required."); return; }
            if (!skipper) { alert("Skipper Name is required."); return; }
            if (isNaN(yardstick) || yardstick <= 0) { alert("Valid positive Yardstick is required."); return; }

            const duplicate = boatList.find(b => b.sailNumber.toUpperCase() === sailNum.toUpperCase() && b.id !== id);
            if (duplicate) {
                alert(`Error: Sail Number "${sailNum}" is already used by ${duplicate.skipper} (${duplicate.boatClass}). Sail Numbers must be unique.`);
                return;
            }

            const boatData = { id: id || Date.now(), sailNumber: sailNum, boatClass: boatClass, skipper: skipper, yardstick: yardstick };
            console.log("Boat data:", boatData); // Logging

            if (id) {
                const index = boatList.findIndex(b => b.id === id);
                if (index !== -1) {
                    console.log("Updating boat at index:", index); // Logging
                    boatList[index] = boatData;
                } else {
                    alert("Error finding boat to update.");
                    console.error("Could not find boat with ID", id, "to update."); // Logging
                    return;
                }
            } else {
                console.log("Adding new boat."); // Logging
                boatList.push(boatData);
            }

            console.log("Boat list length:", boatList.length); // Logging
            console.log("Saving boat list to storage..."); // Logging
            saveBoatListToStorage();
            renderBoatListTable();
            clearBoatListForm();
        });

        function editBoatInList(id) { /* ... MODIFIED to use hidden class ... */
            const boat = boatList.find(b => b.id === id);
            if (!boat) return;
            clearBoatListForm();
            if(editingBoatId) editingBoatId.value = boat.id;
            if(boatSailNumber) boatSailNumber.value = boat.sailNumber;
            if(boatSkipper) boatSkipper.value = boat.skipper;
            if(boatYardstick) boatYardstick.value = boat.yardstick;
            if(boatFormTitle) boatFormTitle.textContent = `Edit Boat: ${boat.sailNumber}`;
            const isStandardClass = yardstickData.some(yc => yc.boatClass === boat.boatClass);
            if (isStandardClass && boatClassList && boatClassList.querySelector(`option[value="${boat.boatClass}"]`)) {
                 if(boatManualClassCheck) boatManualClassCheck.checked = false;
                 if(boatClassList) boatClassList.value = boat.boatClass;
                 if(boatManualClassInput) boatManualClassInput.classList.add('hidden'); // Use class
                 if(boatClassList) boatClassList.disabled = false;
                 if(manualBoatClass) manualBoatClass.value = '';
                 const selectedClassData = yardstickData.find(b => b.boatClass === boatClassList.value);
                 const autoYardstick = selectedClassData ? selectedClassData.yardstick : null;
                 if (autoYardstick !== null && boat.yardstick === autoYardstick) {
                     if(boatManualYardstickCheck) boatManualYardstickCheck.checked = false;
                     if(boatYardstick) boatYardstick.readOnly = true;
                 } else {
                     if(boatManualYardstickCheck) boatManualYardstickCheck.checked = true;
                     if(boatYardstick) boatYardstick.readOnly = false;
                 }
             } else {
                 if(boatManualClassCheck) boatManualClassCheck.checked = true;
                 if(boatManualBoatClass) boatManualBoatClass.value = boat.boatClass;
                 if(boatClassList) boatClassList.value = '';
                 if(boatManualClassInput) boatManualClassInput.classList.remove('hidden'); // Use class
                 if(boatClassList) boatClassList.disabled = true;
                 if(boatManualYardstickCheck) boatManualYardstickCheck.checked = true;
                 if(boatYardstick) boatYardstick.readOnly = false;
             }
            if(boatListForm) {
                boatListForm.classList.remove('hidden'); // Use hidden class
                boatListForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        function deleteBoatFromList(id) { /* ... remains unchanged ... */
            const boatIndex = boatList.findIndex(b => b.id === id);
            if (boatIndex === -1) return;
            const boat = boatList[boatIndex];
            if (confirm(`Are you sure you want to delete ${boat.sailNumber} (${boat.skipper}) from the saved boat list?`)) {
                boatList.splice(boatIndex, 1);
                saveBoatListToStorage();
                renderBoatListTable();
            }
        }
        // Link Boat List form controls to Yardstick Data
        if(boatClassList) boatClassList.addEventListener('change', () => { /* ... remains unchanged ... */
            const selectedClass = boatClassList.value;
            if (selectedClass && boatManualYardstickCheck && !boatManualYardstickCheck.checked) {
                const boatData = yardstickData.find(boat => boat.boatClass === selectedClass);
                if(boatYardstick) { boatYardstick.value = boatData ? boatData.yardstick : ''; boatYardstick.readOnly = true; }
            } else if (!selectedClass && boatManualYardstickCheck && !boatManualYardstickCheck.checked) {
                 if(boatYardstick) { boatYardstick.value = ''; boatYardstick.readOnly = true; }
            } else if (boatManualYardstickCheck && boatManualYardstickCheck.checked) {
                 if(boatYardstick) boatYardstick.readOnly = false;
            }
        });
        if(boatManualClassCheck) boatManualClassCheck.addEventListener('change', () => { /* ... MODIFIED to use hidden class ... */
            const isManual = boatManualClassCheck.checked;
            if(boatClassList) boatClassList.disabled = isManual;
            if(boatManualClassInput) boatManualClassInput.classList.toggle('hidden', !isManual); // Use class
            if (!isManual) {
                if(manualBoatClass) manualBoatClass.value = '';
                if(boatClassList) boatClassList.dispatchEvent(new Event('change'));
            } else {
                 if(boatYardstick) boatYardstick.value = '';
                 if(boatManualYardstickCheck) boatManualYardstickCheck.checked = true;
                 if(boatYardstick) boatYardstick.readOnly = false;
                 if(boatClassList) boatClassList.value = '';
            }
        });
        if(boatManualYardstickCheck) boatManualYardstickCheck.addEventListener('change', () => { /* ... remains unchanged ... */
            const isManual = boatManualYardstickCheck.checked;
            if(boatYardstick) boatYardstick.readOnly = isManual; // Simplified logic
            if (!isManual && boatManualClassCheck && !boatManualClassCheck.checked) {
                if(boatClassList) boatClassList.dispatchEvent(new Event('change'));
            }
        });


        // --- Race Entry Functions ---
        function populateSavedBoatDropdown() { /* ... remains unchanged ... */
            if (!selectSavedBoat) return;
            const currentVal = selectSavedBoat.value;
            selectSavedBoat.innerHTML = '<option value="">-- Select Saved Boat --</option>'; // Reset
            boatList.sort((a,b) => a.sailNumber.localeCompare(b.sailNumber));
            boatList.forEach(boat => {
                const option = document.createElement('option');
                option.value = boat.id;
                option.textContent = `${boat.sailNumber} - ${boat.skipper} (${boat.boatClass})`;
                selectSavedBoat.appendChild(option);
            });
             if (boatList.some(b => b.id == currentVal)) { selectSavedBoat.value = currentVal; }
        }
        if(selectSavedBoat) selectSavedBoat.addEventListener('change', () => { /* ... MODIFIED to use hidden class ... */
            const selectedBoatId = selectSavedBoat.value;
            if (!selectedBoatId) { clearEntryForm(); return; }
            const boat = boatList.find(b => b.id == selectedBoatId);
            if (boat) {
                if(sailNumber) sailNumber.value = boat.sailNumber;
                if(skipperName) skipperName.value = boat.skipper;
                if(yardstickValue) yardstickValue.value = boat.yardstick;
                const isStandardClass = yardstickData.some(yc => yc.boatClass === boat.boatClass);
                if (isStandardClass && boatClassSelect && boatClassSelect.querySelector(`option[value="${boat.boatClass}"]`)) {
                    if(manualClassCheck) manualClassCheck.checked = false;
                    if(boatClassSelect) boatClassSelect.value = boat.boatClass;
                    if(manualClassInput) manualClassInput.classList.add('hidden'); // Use class
                    if(boatClassSelect) boatClassSelect.disabled = false;
                    if(manualBoatClass) manualBoatClass.value = '';
                    const selectedClassData = yardstickData.find(b => b.boatClass === boatClassSelect.value);
                    const autoYardstick = selectedClassData ? selectedClassData.yardstick : null;
                    if (autoYardstick !== null && boat.yardstick === autoYardstick) {
                        if(manualYardstickCheck) manualYardstickCheck.checked = false;
                        if(yardstickValue) yardstickValue.readOnly = true;
                    } else {
                        if(manualYardstickCheck) manualYardstickCheck.checked = true;
                        if(yardstickValue) yardstickValue.readOnly = false;
                    }
                } else {
                    if(manualClassCheck) manualClassCheck.checked = true;
                    if(boatClassSelect) boatClassSelect.value = '';
                    if(manualBoatClass) manualBoatClass.value = boat.boatClass;
                    if(manualClassInput) manualClassInput.classList.remove('hidden'); // Use class
                    if(boatClassSelect) boatClassSelect.disabled = true;
                    if(manualYardstickCheck) manualYardstickCheck.checked = true;
                    if(yardstickValue) yardstickValue.readOnly = false;
                }
                 console.log(`Filled race entry form with data for ${boat.sailNumber}`);
            } else {
                console.warn("Selected saved boat not found in boatList:", selectedBoatId);
                 clearEntryForm();
            }
        });

        function clearEntryForm() { /* ... MODIFIED to use hidden class ... */
             if(sailNumber) sailNumber.value = '';
             if(boatClassSelect) boatClassSelect.value = '';
             if(skipperName) skipperName.value = '';
             if(yardstickValue) yardstickValue.value = '';
             if(elapsedTime) elapsedTime.value = '';
             const finishedRadio = document.getElementById('status-finished');
             if(finishedRadio) finishedRadio.checked = true;
             // Don't automatically show timeInputs, let the series type dictate this
             // if(timeInputs) timeInputs.style.display = 'block';
             if(manualBoatClass) manualBoatClass.value = '';
             if(editingEntryIndexInput) editingEntryIndexInput.value = '-1';
             if(editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = '-1'; // Clear short course edit index too
             if(manualClassCheck) manualClassCheck.checked = false;
             if(manualClassInput) manualClassInput.classList.add('hidden'); // Use class
             if(boatClassSelect) boatClassSelect.disabled = false;
             if(manualYardstickCheck) manualYardstickCheck.checked = false;
             if(yardstickValue) yardstickValue.readOnly = true;
             if(addBoatBtn) addBoatBtn.style.display = 'inline-block';
             if(updateBoatBtn) updateBoatBtn.classList.add('hidden'); // Use class
             if(cancelUpdateBtn) cancelUpdateBtn.classList.add('hidden'); // Use class
             if(selectSavedBoat) selectSavedBoat.value = '';
             if(boatClassSelect) boatClassSelect.dispatchEvent(new Event('change'));
             if(manualClassCheck) manualClassCheck.dispatchEvent(new Event('change'));
             if(manualYardstickCheck) manualYardstickCheck.dispatchEvent(new Event('change'));
             // Only handle status change if fields are potentially visible (standard)
             if (statusRadios.length > 0 && standardEntryFields && !standardEntryFields.classList.contains('hidden')) {
                handleStatusChange();
            }
         }

        // --- Event Listeners for Race Entry Form Class/Yardstick (apply to both modes) ---
         if(boatClassSelect) boatClassSelect.addEventListener('change', () => { /* ... MODIFIED yardstick readonly logic slightly ... */
             const selectedClass = boatClassSelect.value;
             const isYardstickManual = manualYardstickCheck?.checked;
             if (selectedClass && !isYardstickManual) {
                 const boatData = yardstickData.find(boat => boat.boatClass === selectedClass);
                 if(yardstickValue) {
                     yardstickValue.value = boatData ? boatData.yardstick : '';
                     yardstickValue.readOnly = true;
                 }
             } else if (!selectedClass && !isYardstickManual) {
                  if(yardstickValue) {
                      yardstickValue.value = '';
                      yardstickValue.readOnly = true; // Still read-only if dropdown is empty and not manual
                  }
             } else if (isYardstickManual) {
                  if(yardstickValue) yardstickValue.readOnly = false;
             }
         });
         if(manualClassCheck) manualClassCheck.addEventListener('change', () => { /* ... MODIFIED to use hidden class ... */
             const isManual = manualClassCheck.checked;
             if(boatClassSelect) boatClassSelect.disabled = isManual;
             if(manualClassInput) manualClassInput.classList.toggle('hidden', !isManual); // Use class
             if (!isManual) {
                 if(manualBoatClass) manualBoatClass.value = '';
                 if(boatClassSelect) boatClassSelect.dispatchEvent(new Event('change'));
             } else {
                  if(boatClassSelect) boatClassSelect.value = '';
                  if(yardstickValue) yardstickValue.value = ''; // Clear YS when switching to manual class
                  if(manualYardstickCheck) manualYardstickCheck.checked = true; // Force manual YS too
                  if(yardstickValue) yardstickValue.readOnly = false;
                  if(manualBoatClass) manualBoatClass.focus();
             }
         });
         if(manualYardstickCheck) manualYardstickCheck.addEventListener('change', () => { /* ... MODIFIED yardstick readonly logic slightly ... */
             const isManual = manualYardstickCheck.checked;
             if(yardstickValue) yardstickValue.readOnly = isManual; // Direct mapping
             if (!isManual && manualClassCheck && !manualClassCheck.checked && boatClassSelect) {
                 // If switching back to auto YS, AND class is from dropdown, trigger class change to re-fill YS
                 boatClassSelect.dispatchEvent(new Event('change'));
             } else if (!isManual && (!manualClassCheck || manualClassCheck.checked)) {
                 // If switching back to auto YS, but class is manual or selector empty, clear YS value
                 if(yardstickValue) yardstickValue.value = '';
             }
         });
        function handleStatusChange() { // Only for standard entry fields
            const selectedStatus = document.querySelector('input[name="race-status"]:checked')?.value;
            if(timeInputs) timeInputs.style.display = (selectedStatus === 'finished') ? 'block' : 'none';
            if (selectedStatus !== 'finished' && elapsedTime) elapsedTime.value = '';
        }
        statusRadios.forEach(radio => radio.addEventListener('change', handleStatusChange));

        // --- Add/Update/Remove Entries ---
        if(addBoatBtn) addBoatBtn.addEventListener('click', () => {
            const entryData = getEntryFormData();
            if (!entryData) return;

            if (currentSeries?.isShortCourse) {
                // Check for duplicate sail number in the pool
                if (entries.some(e => e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                    alert(`Boat with Sail Number ${entryData.sailNumber} is already in the pool.`);
                    return;
                }
                entries.push(entryData); // Add to pool
                renderShortCoursePoolTable(); // Render pool table
            } else {
                 // Standard Race: Check for duplicate sail number in this race
                 if (!currentRace) { alert("Please select a race number before adding boats."); return; }
                if (entries.some(e => e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                    alert(`Boat with Sail Number ${entryData.sailNumber} is already entered in this race.`);
                    return;
                }
                entries.push(entryData); // Add to standard race list
                renderEntriesTable(); // Render standard table
            }
            clearEntryForm();
            if(sailNumber) sailNumber.focus();
        });

        if(updateBoatBtn) updateBoatBtn.addEventListener('click', () => {
            const entryData = getEntryFormData();
            if (!entryData) return;

            const index = parseInt(editingEntryIndexInput?.value);
            const shortCourseRaceIndex = parseInt(editingShortCourseRaceIndexInput?.value); // Get short course race index

            if (currentSeries?.isShortCourse) {
                // Updating a boat within a specific created short course race
                if (shortCourseRaceIndex >= 0 && shortCourseRaceIndex < shortCourseSessionRaces.length && index >= 0 && index < shortCourseSessionRaces[shortCourseRaceIndex].entries.length) {
                    // Check for duplicate sail number *within that specific short course race* being edited
                    const raceEntries = shortCourseSessionRaces[shortCourseRaceIndex].entries;
                    if (raceEntries.some((e, i) => i !== index && e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                        alert(`Boat with Sail Number ${entryData.sailNumber} is already entered in this race.`);
                        return;
                    }
                    // Update the entry *including* status and time from form (which were populated during edit)
                    shortCourseSessionRaces[shortCourseRaceIndex].entries[index] = {
                        ...entryData, // Basic details (sail#, skipper, class, YS)
                        // Get status/time directly from the form fields as they were visible
                        status: document.querySelector('input[name="race-status"]:checked')?.value || 'finished',
                        elapsedTime: elapsedTime.value || '' // Use the element's value directly here
                    };
                    renderShortCourseSessionRaces(); // Re-render all created race sections
                    clearEntryForm();
                    switchToShortCourseUI(); // Ensure UI is correct after update
                }
                // Updating a boat in the pool
                else if (shortCourseRaceIndex === -1 && index >= 0 && index < entries.length) {
                     // Check for duplicate sail number *within the pool* being edited
                    if (entries.some((e, i) => i !== index && e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                        alert(`Boat with Sail Number ${entryData.sailNumber} is already in the pool.`);
                        return;
                    }
                    // Pool entries don't have status/time, just update basic details
                    entries[index] = {
                        sailNumber: entryData.sailNumber,
                        boatClass: entryData.boatClass,
                        skipper: entryData.skipper,
                        yardstick: entryData.yardstick,
                        status: 'pool', // Internal marker maybe? Not strictly needed.
                        elapsedTime: '' // Pool entries use the empty string from getEntryFormData
                     };
                    renderShortCoursePoolTable();
                    clearEntryForm();
                    switchToShortCourseUI();
                }
                 else { alert('Error updating short course entry. Index out of bounds.'); clearEntryForm(); switchToShortCourseUI(); }
            } else {
                // Standard Race Update
                if (!currentRace) { alert("Error: No standard race selected for update."); return; }
                if (index >= 0 && index < entries.length) {
                    // Check for duplicate sail number *within the standard race* being edited
                    if (entries.some((e, i) => i !== index && e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                        alert(`Boat with Sail Number ${entryData.sailNumber} is already entered in this race.`);
                        return;
                    }
                    // Standard entries include status/time from the form (entryData has correct elapsedTime string now)
                    entries[index] = entryData;
                    renderEntriesTable();
                    clearEntryForm();
                } else { alert('Error updating standard entry. Index out of bounds.'); clearEntryForm(); }
            }
        });

        if(cancelUpdateBtn) cancelUpdateBtn.addEventListener('click', () => {
            clearEntryForm();
            // Ensure the UI reflects the correct mode after cancelling an update
            if (currentSeries?.isShortCourse) {
                switchToShortCourseUI();
            } else {
                switchToStandardRaceUI();
            }
        });

        function getEntryFormData() {
            const sailNum = sailNumber?.value.trim().toUpperCase(); // Ensure uppercase
            let boatClass = manualClassCheck?.checked ? manualBoatClass?.value.trim() : boatClassSelect?.value;
            const skipper = skipperName?.value.trim();
            const yardstick = parseFloat(yardstickValue?.value);

            if (!sailNum) { alert('Sail Number required.'); return null; }
            if (!boatClass) { alert('Boat Class required.'); return null; }
            if (!skipper) { alert('Skipper Name required.'); return null; }
            if (isNaN(yardstick) || yardstick <= 0) { alert('Valid positive Yardstick required.'); return null; }

            let status = 'finished'; // Default or starting point
            let elapsed = ''; // Variable to hold the string value

             // Get status/time only if standard entry fields are visible
             const standardFieldsVisible = standardEntryFields && !standardEntryFields.classList.contains('hidden');
             if (standardFieldsVisible) {
                 status = document.querySelector('input[name="race-status"]:checked')?.value;
                 elapsed = elapsedTime?.value.trim(); // Read value into 'elapsed'

                 if (!status) { alert('Race Status required.'); return null; }
                 if (status === 'finished') { if (!isValidTimeFormat(elapsed)) { alert('Valid elapsed time (hh:mm:ss) required for finished status.'); return null; } }
                 else { elapsed = ''; } // Clear elapsed time if not finished
             } else {
                // If standard fields hidden (short course pool entry/add), status/time aren't relevant from form
                status = ''; // Or maybe 'pool'? Let's leave empty for now.
                elapsed = '';
             }

            // ******** FIX: Use the 'elapsed' variable containing the string value ********
            return { sailNumber: sailNum, boatClass, skipper, yardstick, status, elapsedTime: elapsed };
        }

        // Render standard entries table
        function renderEntriesTable() {
            if (!entriesBody) return;
            entriesBody.innerHTML = '';
             const raceNumText = currentRace ? ` Race ${currentRace}` : '';
             if(currentEntriesHeading) currentEntriesHeading.textContent = `Current Entries for Selected${raceNumText}`;

            if (entries.length === 0) {
                const row = entriesBody.insertRow(); const cell = row.insertCell();
                cell.colSpan = 7; cell.textContent = currentRace ? 'No entries added yet for this race.' : 'Select a race to view/add entries.';
                cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }
            entries.forEach((entry, index) => {
                const row = entriesBody.insertRow();
                // Now entry.elapsedTime should be the string or ''
                row.innerHTML = `<td>${entry.sailNumber}</td><td>${entry.boatClass}</td><td>${entry.skipper}</td><td>${entry.yardstick}</td><td>${entry.status.toUpperCase()}</td><td>${entry.elapsedTime || '-'}</td><td class="actions"><button class="btn-edit" onclick="editEntry(${index})">Edit</button><button class="btn-danger" onclick="removeEntry(${index})">Rem</button></td>`;
            });
        }

        // Render short course pool table
        function renderShortCoursePoolTable() {
            if (!shortCoursePoolBody) return;
            shortCoursePoolBody.innerHTML = '';
             const poolCount = entries.length;
             if(shortCoursePoolHeading) shortCoursePoolHeading.textContent = `Next Race Pool (${poolCount} ${pluralize(poolCount, 'Boat')})`;

            if (poolCount === 0) {
                const row = shortCoursePoolBody.insertRow(); const cell = row.insertCell();
                cell.colSpan = 5; cell.textContent = 'Add boats using the form above to create the pool for the next race.';
                cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }
            entries.forEach((entry, index) => {
                const row = shortCoursePoolBody.insertRow();
                // Note: Pool table doesn't have status/time columns
                row.innerHTML = `<td>${entry.sailNumber}</td><td>${entry.boatClass}</td><td>${entry.skipper}</td><td>${entry.yardstick}</td><td class="actions"><button class="btn-edit" onclick="editEntry(${index})">Edit</button><button class="btn-danger" onclick="removeEntry(${index})">Rem</button></td>`;
            });
        }

        // Edit an entry (handles both standard and short course pool)
        function editEntry(index) {
            let entry;
            let editingTarget = ''; // 'standard' or 'pool'

            if (currentSeries?.isShortCourse) {
                // Editing from the pool table
                 if (index >= 0 && index < entries.length) {
                     entry = entries[index];
                     editingTarget = 'pool';
                 } else { return; } // Invalid index
                 if (editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = -1; // Not editing within a race
            } else {
                 // Editing from standard race table
                 if (!currentRace) { console.error("Attempting to edit standard entry with no race selected."); return; }
                 if (index >= 0 && index < entries.length) {
                     entry = entries[index];
                     editingTarget = 'standard';
                 } else { return; } // Invalid index
            }

            if (!entry) return;

            clearEntryForm();
            // Populate common fields
            if(sailNumber) sailNumber.value = entry.sailNumber;
            if(skipperName) skipperName.value = entry.skipper;
            if(yardstickValue) yardstickValue.value = entry.yardstick;
            if(editingEntryIndexInput) editingEntryIndexInput.value = index;

            // Populate status/time ONLY for standard entries
            if (editingTarget === 'standard') {
                 // Use the entry.elapsedTime string here
                 if(elapsedTime) elapsedTime.value = entry.elapsedTime;
                 try { const statusRadio = document.getElementById(`status-${entry.status.toLowerCase()}`); if(statusRadio) statusRadio.checked = true; handleStatusChange(); } catch (e) { console.warn("Status ID not found:", entry.status); }
                 if (standardEntryFields) standardEntryFields.classList.remove('hidden'); // Ensure visible
            } else {
                 if (standardEntryFields) standardEntryFields.classList.add('hidden'); // Hide for pool edit
            }

            // Populate boat class / yardstick manual checks (common logic) - Use class
            const isStandardClass = yardstickData.some(yc => yc.boatClass === entry.boatClass);
            if (isStandardClass && boatClassSelect && boatClassSelect.querySelector(`option[value="${entry.boatClass}"]`)) {
                if(manualClassCheck) manualClassCheck.checked = false;
                if(boatClassSelect) boatClassSelect.value = entry.boatClass;
                if(manualClassInput) manualClassInput.classList.add('hidden'); // Use class
                if(boatClassSelect) boatClassSelect.disabled = false;
                if(manualBoatClass) manualBoatClass.value = '';
                const boatData = yardstickData.find(b => b.boatClass === boatClassSelect.value);
                const autoYardstick = boatData ? boatData.yardstick : null;
                if (autoYardstick !== null && entry.yardstick === autoYardstick) {
                    if(manualYardstickCheck) manualYardstickCheck.checked = false;
                    if(yardstickValue) yardstickValue.readOnly = true;
                } else {
                    if(manualYardstickCheck) manualYardstickCheck.checked = true;
                    if(yardstickValue) yardstickValue.readOnly = false;
                }
            } else {
                 if(manualClassCheck) manualClassCheck.checked = true;
                 if(manualBoatClass) manualBoatClass.value = entry.boatClass;
                 if(boatClassSelect) boatClassSelect.value = '';
                 if(manualClassInput) manualClassInput.classList.remove('hidden'); // Use class
                 if(boatClassSelect) boatClassSelect.disabled = true;
                 if(manualYardstickCheck) manualYardstickCheck.checked = true;
                 if(yardstickValue) yardstickValue.readOnly = false;
            }

            if(addBoatBtn) addBoatBtn.style.display = 'none';
            if(updateBoatBtn) updateBoatBtn.classList.remove('hidden'); // Use class
            if(cancelUpdateBtn) cancelUpdateBtn.classList.remove('hidden'); // Use class
            if(sailNumber) { sailNumber.focus(); sailNumber.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }

        // Edit an entry *within* a created short course race section
        function editShortCourseEntry(raceIndex, entryIndex) {
            if (!currentSeries?.isShortCourse || raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for editShortCourseEntry:", raceIndex, entryIndex);
                return;
            }
            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            if (!entry) return;

            clearEntryForm();
            // Populate common fields
            if(sailNumber) sailNumber.value = entry.sailNumber;
            if(skipperName) skipperName.value = entry.skipper;
            if(yardstickValue) yardstickValue.value = entry.yardstick;
            if(editingEntryIndexInput) editingEntryIndexInput.value = entryIndex; // Store entry index
            if(editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = raceIndex; // Store race index

            // Populate status/time fields (as these ARE editable within the short course race)
            if(elapsedTime) elapsedTime.value = entry.elapsedTime || '';
            try {
                const statusRadio = document.getElementById(`status-${entry.status.toLowerCase()}`);
                if(statusRadio) statusRadio.checked = true; else document.getElementById('status-finished').checked = true; // Default if status invalid
                handleStatusChange(); // Update time input visibility based on status
            } catch (e) { console.warn("Status ID not found:", entry.status); if(document.getElementById('status-finished')) document.getElementById('status-finished').checked = true; handleStatusChange(); }
            if (standardEntryFields) standardEntryFields.classList.remove('hidden'); // Show status/time fields

             // Populate boat class / yardstick manual checks (same logic as editEntry) - Use class
             const isStandardClass = yardstickData.some(yc => yc.boatClass === entry.boatClass);
             if (isStandardClass && boatClassSelect && boatClassSelect.querySelector(`option[value="${entry.boatClass}"]`)) {
                 if(manualClassCheck) manualClassCheck.checked = false;
                 if(boatClassSelect) boatClassSelect.value = entry.boatClass;
                 if(manualClassInput) manualClassInput.classList.add('hidden');
                 if(boatClassSelect) boatClassSelect.disabled = false;
                 if(manualBoatClass) manualBoatClass.value = '';
                 const boatData = yardstickData.find(b => b.boatClass === boatClassSelect.value);
                 const autoYardstick = boatData ? boatData.yardstick : null;
                 if (autoYardstick !== null && entry.yardstick === autoYardstick) {
                     if(manualYardstickCheck) manualYardstickCheck.checked = false;
                     if(yardstickValue) yardstickValue.readOnly = true;
                 } else {
                     if(manualYardstickCheck) manualYardstickCheck.checked = true;
                     if(yardstickValue) yardstickValue.readOnly = false;
                 }
             } else {
                 if(manualClassCheck) manualClassCheck.checked = true;
                 if(manualBoatClass) manualBoatClass.value = entry.boatClass;
                 if(boatClassSelect) boatClassSelect.value = '';
                 if(manualClassInput) manualClassInput.classList.remove('hidden');
                 if(boatClassSelect) boatClassSelect.disabled = true;
                 if(manualYardstickCheck) manualYardstickCheck.checked = true;
                 if(yardstickValue) yardstickValue.readOnly = false;
             }

            if(addBoatBtn) addBoatBtn.style.display = 'none';
            if(updateBoatBtn) updateBoatBtn.classList.remove('hidden');
            if(cancelUpdateBtn) cancelUpdateBtn.classList.remove('hidden');
            if(sailNumber) { sailNumber.focus(); sailNumber.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }


        // Remove entry (handles standard races and short course pool)
        function removeEntry(index) {
            let targetArray;
            let renderFunction;

            if (currentSeries?.isShortCourse) {
                // Removing from pool
                targetArray = entries;
                renderFunction = renderShortCoursePoolTable;
            } else {
                // Removing from standard race
                 if (!currentRace) { console.error("Attempting to remove standard entry with no race selected."); return; }
                targetArray = entries;
                renderFunction = renderEntriesTable;
            }

            if (index < 0 || index >= targetArray.length) return;
            if (confirm(`Remove entry for ${targetArray[index]?.sailNumber || 'this boat'}?`)) {
                targetArray.splice(index, 1);
                renderFunction(); // Re-render the correct table
                // If the removed item was being edited, clear the form
                if (editingEntryIndexInput && parseInt(editingEntryIndexInput.value) === index && parseInt(editingShortCourseRaceIndexInput?.value) === -1) { // Check it wasn't a short course race edit
                    clearEntryForm();
                    if (currentSeries?.isShortCourse) switchToShortCourseUI(); else switchToStandardRaceUI();
                }
            }
        }

         // Remove an entry *within* a created short course race section
         function removeShortCourseEntry(raceIndex, entryIndex) {
            if (!currentSeries?.isShortCourse || raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for removeShortCourseEntry:", raceIndex, entryIndex);
                return;
            }
            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            if (confirm(`Remove entry for ${entry?.sailNumber || 'this boat'} from Race ${raceIndex + 1}?`)) {
                shortCourseSessionRaces[raceIndex].entries.splice(entryIndex, 1);
                renderShortCourseSessionRaces(); // Re-render the created races section
                 // If the removed item was being edited, clear the form
                 if (editingEntryIndexInput && parseInt(editingEntryIndexInput.value) === entryIndex && editingShortCourseRaceIndexInput && parseInt(editingShortCourseRaceIndexInput.value) === raceIndex) {
                    clearEntryForm();
                    switchToShortCourseUI(); // Stay in short course UI
                 }
            }
         }


        if(clearAllBtn) clearAllBtn.addEventListener('click', () => {
            if (currentSeries?.isShortCourse) {
                // Clear the pool
                if (entries.length === 0) { alert("Boat pool is already empty."); return; }
                if (confirm('Clear all boats from the Next Race Pool? (Does not affect created races).')) {
                    entries = [];
                    renderShortCoursePoolTable();
                    clearEntryForm();
                }
            } else {
                // Clear standard entries
                 if (!currentRace) { alert("Please select a race before clearing entries."); return; }
                if (entries.length === 0) { alert("Entry list is already empty for this race."); return; }
                if (confirm(`Clear all current entries in this list for Race ${currentRace}? (Does not affect saved data).`)) {
                    entries = [];
                    renderEntriesTable();
                    clearEntryForm();
                }
            }
        });
        if(clearFormBtn) clearFormBtn.addEventListener('click', () => {
             clearEntryForm();
             // Ensure UI is correct after clearing form
             if (currentSeries?.isShortCourse) {
                 switchToShortCourseUI();
             } else {
                 switchToStandardRaceUI();
             }
        });

        // --- Short Course Specific Functions ---

        // Listener for the "Create Race N" button
        if (createShortCourseRaceBtn) createShortCourseRaceBtn.addEventListener('click', () => {
            if (entries.length === 0) {
                alert("The 'Next Race Pool' is empty. Add boats before creating a race.");
                return;
            }
            if (!currentSeries || !currentSeries.isShortCourse) {
                 alert("Error: Cannot create short course race - current series is not set or not a short course series.");
                 return;
            }

            const nextRaceNumber = shortCourseSessionRaces.length + 1;
            // Deep copy entries from the pool and add default status/time
            const raceEntries = JSON.parse(JSON.stringify(entries)).map(entry => ({
                ...entry,
                status: 'finished', // Default status
                elapsedTime: ''     // Default time
            }));

            shortCourseSessionRaces.push({
                raceNumber: nextRaceNumber,
                entries: raceEntries
            });

            renderShortCourseSessionRaces(); // Update the display of created races
            updateCreateRaceButton(); // Update button text (e.g., "Create Race 2")
            // Pool ('entries' array) is intentionally *not* cleared here
        });

        // Render all created race sections for the current short course session
        function renderShortCourseSessionRaces() {
            if (!shortCourseRacesContainer) return;
            shortCourseRacesContainer.innerHTML = '<h3>Created Races (This Session)</h3>'; // Reset container

            if (shortCourseSessionRaces.length === 0) {
                 shortCourseRacesContainer.innerHTML += '<p>No races created yet in this session.</p>';
                 return;
            }

            shortCourseSessionRaces.forEach((raceData, raceIndex) => {
                const raceSection = document.createElement('div');
                raceSection.classList.add('short-course-race-section');
                raceSection.dataset.raceIndex = raceIndex; // Store index for event handlers

                let tableHTML = `<h4>Race ${raceData.raceNumber} (${raceData.entries.length} ${pluralize(raceData.entries.length, 'Boat')})</h4>
                    <div style="overflow-x: auto;">
                    <table class="short-course-race-table">
                        <thead>
                            <tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Status</th><th>Elapsed Time</th><th>Actions</th></tr>
                        </thead>
                        <tbody>`;

                raceData.entries.forEach((entry, entryIndex) => {
                    // Generate options for the status dropdown
                    const statusOptions = ['finished', 'DNF', 'DNS', 'OCS', 'DSQ', 'OOD']
                        .map(s => `<option value="${s}" ${entry.status === s ? 'selected' : ''}>${s.toUpperCase()}</option>`)
                        .join('');

                    tableHTML += `
                        <tr data-entry-index="${entryIndex}">
                            <td>${entry.sailNumber}</td>
                            <td>${entry.boatClass}</td>
                            <td>${entry.skipper}</td>
                            <td>${entry.yardstick}</td>
                            <td class="short-course-race-entry">
                                <select class="sc-status-select" onchange="updateShortCourseEntry(${raceIndex}, ${entryIndex}, 'status', this.value)">
                                    ${statusOptions}
                                </select>
                            </td>
                            <td class="short-course-race-entry">
                                <input type="text" class="sc-time-input" value="${entry.elapsedTime || ''}" placeholder="hh:mm:ss" oninput="updateShortCourseEntry(${raceIndex}, ${entryIndex}, 'elapsedTime', this.value)" ${entry.status !== 'finished' ? 'disabled' : ''}>
                            </td>
                            <td class="actions">
                                <button class="btn-edit" onclick="editShortCourseEntry(${raceIndex}, ${entryIndex})">Edit</button>
                                <button class="btn-danger" onclick="removeShortCourseEntry(${raceIndex}, ${entryIndex})">Rem</button>
                            </td>
                        </tr>`;
                });

                tableHTML += `</tbody></table></div>`;
                raceSection.innerHTML = tableHTML;
                shortCourseRacesContainer.appendChild(raceSection);
            });
        }

        // Update status or time for an entry within a short course race session
        function updateShortCourseEntry(raceIndex, entryIndex, field, value) {
            if (raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for updateShortCourseEntry"); return;
            }

            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            entry[field] = value;

            // If status changed, enable/disable time input and clear if needed
            if (field === 'status') {
                const row = shortCourseRacesContainer.querySelector(`div[data-race-index="${raceIndex}"] tr[data-entry-index="${entryIndex}"]`);
                const timeInput = row?.querySelector('.sc-time-input');
                if (timeInput) {
                    timeInput.disabled = (value !== 'finished');
                    if (value !== 'finished') {
                        timeInput.value = '';
                        entry.elapsedTime = ''; // Update data model too
                    }
                }
            }
             // Basic validation feedback for time input could be added here later if desired
             if (field === 'elapsedTime' && entry.status === 'finished' && value && !isValidTimeFormat(value)) {
                 // Maybe add a visual cue like a red border temporarily
                 console.warn("Invalid time format entered:", value);
             }
        }


        // Update the "Create Race N" button text
        function updateCreateRaceButton() {
            if (createShortCourseRaceBtn) {
                const nextRaceNum = shortCourseSessionRaces.length + 1;
                createShortCourseRaceBtn.textContent = `Create Race ${nextRaceNum}`;
            }
        }

        // Clear the short course session data and UI
        function clearShortCourseSessionData() {
            shortCourseSessionRaces = [];
            if (shortCourseRacesContainer) shortCourseRacesContainer.innerHTML = '<h3>Created Races (This Session)</h3><p>No races created yet in this session.</p>'; // Clear UI
            updateCreateRaceButton(); // Reset button text
        }
         if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.addEventListener('click', () => {
            if (shortCourseSessionRaces.length === 0) {
                 alert("There are no created races in this session to clear.");
                 return;
            }
            if (confirm(`Are you sure you want to clear the ${shortCourseSessionRaces.length} ${pluralize(shortCourseSessionRaces.length, 'race')} created in this session? This cannot be undone.`)) {
                clearShortCourseSessionData();
            }
         });


        // --- Results Calculation (MODIFIED for Short Course) ---
        if(calculateResultsBtn) calculateResultsBtn.addEventListener('click', () => {
            if (currentSeries?.isShortCourse) {
                 // --- SHORT COURSE CALCULATION & SAVE ---
                 if (shortCourseSessionRaces.length === 0) {
                    alert("No races have been created in this session. Use the 'Create Race N' button first.");
                    return;
                 }
                 if (!currentSeries) {
                     alert("Error: No series selected."); return;
                 }

                 console.log(`Calculating and saving ${shortCourseSessionRaces.length} short course races for series: ${currentSeries.name}`);

                 try {
                     let racesAddedCount = 0;
                     const seriesToUpdate = series.find(s => s.id === currentSeries.id);
                     if (!seriesToUpdate) throw new Error("Could not find the series in the main data array.");

                     // Find the highest existing race number in the series to append correctly
                     const maxExistingRaceNum = seriesToUpdate.races.reduce((max, race) => Math.max(max, race.raceNumber), 0);
                     let nextRaceNum = maxExistingRaceNum + 1;

                     for (const sessionRaceData of shortCourseSessionRaces) { // Use for...of for cleaner async potential later
                         console.log(`Processing session race ${sessionRaceData.raceNumber} (to become Race ${nextRaceNum})`);
                         // Validate entries for this race (e.g., time format for 'finished')
                         const invalidTimeEntry = sessionRaceData.entries.find(e => e.status === 'finished' && !isValidTimeFormat(e.elapsedTime));
                         if (invalidTimeEntry) {
                             throw new Error(`Invalid time format for ${invalidTimeEntry.sailNumber} in Race ${sessionRaceData.raceNumber}. Please correct before calculating.`);
                         }

                         // 1. Calculate results for this specific race
                         const calculatedResults = calculateSingleRaceResults(sessionRaceData.entries, seriesToUpdate); // Pass series for DNC context

                         // 2. Create the final race object to save
                         const raceToSave = {
                             raceNumber: nextRaceNum,
                             date: new Date().toISOString().split('T')[0], // Use today's date
                             entries: JSON.parse(JSON.stringify(sessionRaceData.entries)), // Save the state including status/time
                             results: calculatedResults
                         };

                         // 3. Add to the main series data
                         seriesToUpdate.races.push(raceToSave);
                         racesAddedCount++;
                         nextRaceNum++;
                     }

                     // Update the number of races if it was fixed (less important for short course, but good practice)
                     seriesToUpdate.numberOfRaces = seriesToUpdate.races.length; // Reflect actual count for short course
                     // Sort races just in case
                     seriesToUpdate.races.sort((a, b) => a.raceNumber - b.raceNumber);

                     // 4. Save the updated series data
                     saveSeriesToStorage();

                     // 5. Clear the session data
                     const seriesIdJustUpdated = seriesToUpdate.id;
                     clearShortCourseSessionData();

                     // 6. Refresh UI elements
                     refreshSeriesDropdowns();
                     refreshSeriesList();

                      // 7. Navigate to Race Viewer and select the updated series
                      alert(`${racesAddedCount} ${pluralize(racesAddedCount, 'race')} added and saved to series "${seriesToUpdate.name}".`);
                      setActiveTab(raceViewTab);
                      if(viewAllSeries) viewAllSeries.value = seriesIdJustUpdated; // Select the series
                      displayRaceViewer(); // Display the viewer for the updated series


                 } catch (error) {
                     console.error("Error calculating or saving short course races:", error);
                     alert("Error: " + error.message);
                 }

            } else {
                // --- STANDARD RACE CALCULATION ---
                if (entries.length === 0) { alert('Add at least one boat entry first.'); return; }
                if (!currentSeries || !currentRace) { alert("Select a series and race number first."); return; }

                results = calculateSingleRaceResults(entries, currentSeries, currentRace); // Use the refactored function

                setActiveTab(resultsTab);
                if (resultsSeries) resultsSeries.value = currentSeries.id;
                updateResultsRaceDropdown(false); // Update dropdown without reloading data yet
                if (resultsRace) {
                    const raceOptionValue = String(currentRace);
                    const raceOptionExists = Array.from(resultsRace.options).some(opt => opt.value === raceOptionValue);
                    if (raceOptionExists) { resultsRace.value = raceOptionValue; }
                    else if (resultsRace.options.length > 0) { resultsRace.selectedIndex = 0; currentRace = parseInt(resultsRace.value); }
                }
                renderRaceResults(); // Display calculated results
                disableDirectEditMode();
                if (resultRaceInfo) {
                    const infoPanel = resultRaceInfo.querySelector('.race-info-panel');
                    const infoHtml = infoPanel ? infoPanel.outerHTML : '';
                    resultRaceInfo.innerHTML = infoHtml + `<p style="color: orange; font-weight: bold; margin-top: 10px;">Results have been calculated. Please review carefully. If everything is correct, click 'Save These Results to Series' to finalize and save them.</p>`;
                }
            }
        });

         // Refactored function to calculate results for a SINGLE race's entries
         // Takes entries array, the series object (for DNC rule/context), and optionally the race number (for OOD context)
        function calculateSingleRaceResults(raceEntries, targetSeries, raceNumberForOOD = null) {
             if (!raceEntries || raceEntries.length === 0) return [];

             let calculated = JSON.parse(JSON.stringify(raceEntries)); // Deep copy

             calculated.forEach(result => {
                 if (result.status === 'finished') {
                     // Ensure elapsedTime is a valid string before processing
                     if (typeof result.elapsedTime === 'string' && result.elapsedTime.length > 0) {
                         const elapsedSeconds = timeToSeconds(result.elapsedTime);
                         // Ensure yardstick is valid before division
                         if (result.yardstick && result.yardstick > 0) {
                             const correctedSeconds = elapsedSeconds * 100 / result.yardstick;
                             result.correctedSeconds = correctedSeconds;
                             result.correctedTime = secondsToTime(correctedSeconds);
                         } else {
                             console.warn(`Invalid yardstick (${result.yardstick}) for ${result.sailNumber} - cannot calculate corrected time.`);
                             result.correctedSeconds = Infinity; // Treat as non-finisher for sorting
                             result.correctedTime = 'Error: YS';
                         }
                     } else {
                          console.warn(`Invalid or missing elapsedTime string for ${result.sailNumber} (Status: ${result.status}). Setting corrected time to Infinity.`);
                          result.correctedSeconds = Infinity; // Treat as non-finisher for sorting
                          result.correctedTime = 'Error: Time';
                     }
                 } else {
                     result.correctedSeconds = null;
                     result.correctedTime = null;
                 }
             });

             calculated.sort((a, b) => {
                 const statusOrder = { finished: 0, OOD: 1, DNF: 2, DSQ: 3, OCS: 4, DNS: 5 };
                 const statusA = statusOrder[a.status] ?? 99;
                 const statusB = statusOrder[b.status] ?? 99;
                 if (statusA !== statusB) return statusA - statusB;
                 if (a.status === 'finished') {
                     // Handle potential errors where correctedSeconds might be Infinity or null
                     const correctedA = a.correctedSeconds ?? Infinity;
                     const correctedB = b.correctedSeconds ?? Infinity;
                     return correctedA - correctedB;
                 }
                 return 0; // Keep original order for same non-finishing status
             });

             let position = 1;
             let nonFinishersScore;
             const dncRule = targetSeries?.dncScoringRule || 'raceEntries'; // Default if series context missing

             if (dncRule === 'raceEntries') {
                 nonFinishersScore = calculated.length + 1; // Use total entries in this specific race
             } else {
                 // Need total unique competitors *in the series* (based on SAVED results + current entries)
                 const allCompetitorsInSeries = new Set();
                 // Add from saved races in the target series
                 targetSeries?.races?.forEach(r => {
                     if (r.results) r.results.forEach(res => allCompetitorsInSeries.add(res.sailNumber));
                     // Also consider saved entries if results aren't saved yet (less common scenario now)
                     else if (r.entries) r.entries.forEach(ent => allCompetitorsInSeries.add(ent.sailNumber));
                 });
                 // Add competitors from the current race being calculated if they aren't already counted
                 raceEntries.forEach(e => allCompetitorsInSeries.add(e.sailNumber));
                 nonFinishersScore = allCompetitorsInSeries.size + 1;
             }


             calculated.forEach((result, i) => {
                 if (result.status === 'finished') {
                      // Ensure a valid corrected time exists before attempting position assignment based on it
                     if (result.correctedSeconds === null || result.correctedSeconds === Infinity) {
                         result.position = 'Error'; // Assign error state if corrected time calculation failed
                     } else if (i > 0 && calculated[i-1].status === 'finished' &&
                         typeof result.correctedSeconds === 'number' && typeof calculated[i-1].correctedSeconds === 'number' &&
                         // Use a small tolerance for floating point comparisons? Maybe not needed for PY.
                         result.correctedSeconds === calculated[i-1].correctedSeconds)
                     {
                          result.position = calculated[i-1].position; // Assign same position for ties
                     } else {
                         result.position = position; // Assign current position value
                     }
                      // Only increment position *value* if the current boat wasn't an error and wasn't tied with previous valid finisher
                      if (result.position !== 'Error' && (i === 0 || result.position !== calculated[i-1].position || calculated[i-1].position === 'Error')) {
                           position++; // Increment for the next potential position
                      }
                 } else {
                     result.position = result.status.toUpperCase(); // DNF, DNS etc.
                 }
             });

             // Assign points after positions are set
             calculated.forEach(result => {
                 if (result.status === 'finished') {
                    // Assign points based on numeric position, handle 'Error' position case
                    if (typeof result.position === 'number') {
                        result.points = result.position;
                    } else {
                        console.warn(`Assigning non-finisher points to ${result.sailNumber} due to position error.`);
                        result.points = nonFinishersScore; // Assign non-finisher points if position calc failed
                    }
                 } else if (['DNF', 'DNS', 'OCS', 'DSQ'].includes(result.status)) {
                     result.points = nonFinishersScore;
                 } else if (result.status === 'OOD') {
                     // Pass the *currently calculated* results array for fallback, and series context
                     result.points = calculateOODPoints(result.sailNumber, calculated, targetSeries, raceNumberForOOD);
                 } else {
                     result.points = null; // Should not happen if status is valid
                 }
             });

             return calculated;
         }


        // Calculate OOD Points (Modified to accept current race entries for fallback)
        function calculateOODPoints(sailNo, currentRaceCalculatedResults, targetSeries, oodRaceNumber) {
            // Fallback: Use average of finishers in the race being calculated
            const finishersInCurrentRace = currentRaceCalculatedResults.filter(r => r.status === 'finished' && typeof r.points === 'number');
            let fallbackPoints = 0;
            if (finishersInCurrentRace.length > 0) {
                const avgFinisherPoints = finishersInCurrentRace.reduce((sum, r) => sum + r.points, 0) / finishersInCurrentRace.length;
                fallbackPoints = Math.round(avgFinisherPoints * 10) / 10;
            } else {
                // Ultimate fallback: if no finishers in current race either, give 0? Or maybe 1? Use 0.
                fallbackPoints = 0;
            }

            if (!targetSeries || oodRaceNumber === null) {
                console.warn("Calculating OOD points without full series/race context. Using current race fallback:", fallbackPoints);
                return fallbackPoints;
            }

            let racePoints = [];
            let racesSailedCount = 0;

            // Look through *saved* results in the series
            targetSeries.races.forEach(race => {
                 // Skip the race the person was OOD for
                 if (race.raceNumber !== oodRaceNumber && race.results && race.results.length > 0) {
                     const boatResult = race.results.find(r => r.sailNumber === sailNo);
                     // Only count 'finished' races for average
                     if (boatResult && typeof boatResult.points === 'number' && boatResult.status === 'finished') {
                         racePoints.push(boatResult.points);
                         racesSailedCount++;
                     }
                 }
             });

            if (racesSailedCount > 0) {
                const avgPoints = racePoints.reduce((sum, pts) => sum + pts, 0) / racesSailedCount;
                return Math.round(avgPoints * 10) / 10; // Average of previous finished results
            } else {
                 console.warn(`OOD Fallback: No previous results found for ${sailNo}. Using current race fallback: ${fallbackPoints}.`);
                 return fallbackPoints; // Use the calculated fallback
             }
         }


        // --- Race Results Tab Functions ---
        function renderRaceResults() { /* ... remains unchanged ... */
            if (!resultsBody || !resultRaceInfo) return;
            resultsBody.innerHTML = '';
            const seriesName = currentSeries ? currentSeries.name : (resultsSeries?.options[resultsSeries?.selectedIndex]?.text || 'N/A');
            const raceNumber = currentRace || resultsRace?.value || 'N/A';
            const raceData = currentSeries?.races.find(r => r.raceNumber === parseInt(raceNumber));
            const date = raceData?.date ? new Date(raceData.date + 'T00:00:00').toLocaleDateString() : 'Not set';

            let statusMessage = ''; const statusPara = resultRaceInfo.querySelector('p[style*="color: orange"]'); if (statusPara) statusMessage = statusPara.outerHTML;
            resultRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race Information</h3><p><strong>Series:</strong> ${seriesName}</p><p><strong>Race Number:</strong> ${raceNumber}</p><p><strong>Entries Shown:</strong> ${results?.length || 0}</p></div>` + statusMessage;

            if (!results || results.length === 0) {
                 const existingInfo = resultRaceInfo.innerHTML;
                 resultRaceInfo.innerHTML = existingInfo + '<p>No results calculated or loaded for this race.</p>';
                 const row = resultsBody.insertRow(); const cell = row.insertCell(); cell.colSpan = 10;
                 cell.textContent = 'No results to display.'; cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }

            results.forEach((result, index) => {
                const row = resultsBody.insertRow(); row.dataset.index = index;
                if (directEditMode) row.classList.add('result-highlight');
                row.innerHTML = `
                    <td>${result.position ?? '-'}</td><td>${result.sailNumber}</td><td>${result.boatClass}</td><td>${result.skipper}</td>
                    <td>${result.yardstick}</td><td>${result.status.toUpperCase()}</td><td>${result.elapsedTime || '-'}</td><td>${result.correctedTime || '-'}</td>
                    <td>${result.points ?? '-'}</td><td class="actions">
                        <button class="btn-edit edit-result-btn ${directEditMode ? '' : 'hidden'}" onclick="showEditResultDialog(${index})">Edit</button>
                    </td>`;
            });
        }

        if(saveResultsTabBtn) saveResultsTabBtn.addEventListener('click', () => { /* ... remains unchanged ... */
            const seriesId = resultsSeries?.value; const raceNumStr = resultsRace?.value;
            if (!seriesId || !raceNumStr) { alert("Select Series and Race first."); return; }
            const raceNum = parseInt(raceNumStr);
            if (!results) { alert("No results data available to save."); return; }
            if (results.length === 0 && !confirm(`No results displayed for Race ${raceNum}. Save as having no results? This clears previous results.`)) { return; }
            const targetSeries = series.find(s => s.id === parseInt(seriesId)); if (!targetSeries) { alert("Error: Series not found."); return; }
            if (targetSeries.isShortCourse) {
                alert("Saving for short courses is done via the 'Calculate Race Results & View' button on the Race Entry tab after creating races.");
                return;
            }
            const raceIndex = targetSeries.races.findIndex(race => race.raceNumber === raceNum); if (raceIndex === -1) { alert(`Error: Race ${raceNum} not found in series.`); return; }
            const existingSavedResults = targetSeries.races[raceIndex].results;
            if (existingSavedResults && existingSavedResults.length > 0 && results.length > 0 && !confirm(`Race ${raceNum} already has saved results. Overwrite?`)) { return; }
            const resultsToSave = JSON.parse(JSON.stringify(results));
            const entriesToSave = resultsToSave.map(res => ({ sailNumber: res.sailNumber, boatClass: res.boatClass, skipper: res.skipper, yardstick: res.yardstick, status: res.status, elapsedTime: res.elapsedTime || '' }));
            let dateToSave = targetSeries.races[raceIndex].date || new Date().toISOString().split('T')[0]; // Use existing or today

            try {
                targetSeries.races[raceIndex].date = dateToSave;
                targetSeries.races[raceIndex].entries = entriesToSave;
                targetSeries.races[raceIndex].results = resultsToSave;
                saveSeriesToStorage();
                editMode = false; editModeWarning?.classList.add('hidden');
                disableDirectEditMode();
                alert(`Race ${raceNum} results saved successfully for series "${targetSeries.name}".`);
                refreshSeriesDropdowns();
                if (resultsSeries) resultsSeries.value = seriesId;
                updateResultsRaceDropdown(false); if (resultsRace) resultsRace.value = raceNumStr;
                loadRaceResults();
                if (seriesResultsTab && seriesResultsTab.classList.contains('active-tab') && viewSeries?.value === seriesId) calculateSeriesResults();
                if (raceViewTab && raceViewTab.classList.contains('active-tab') && viewAllSeries?.value === seriesId) {
                    displayRaceViewer();
                    const raceButton = raceSelector?.querySelector(`.race-button[data-race-number="${raceNum}"]`);
                    if (raceButton) { document.querySelectorAll('.race-button.active').forEach(b => b.classList.remove('active')); raceButton.classList.add('active'); displayRaceResultsView(targetSeries, raceNum); }
                }
            } catch (error) { console.error("Error saving race results:", error); alert("Error saving race results."); }
        });

        if(editRaceEntriesBtn) editRaceEntriesBtn.addEventListener('click', () => { /* ... logic modified slightly for short course check ... */
            const seriesId = resultsSeries?.value; const raceNumStr = resultsRace?.value; if (!seriesId || !raceNumStr) { alert('Select Series and Race first.'); return; }
            const raceNum = parseInt(raceNumStr); const seriesForEdit = series.find(s => s.id === parseInt(seriesId)); if (!seriesForEdit) { alert("Series not found."); return; }
            if (seriesForEdit.isShortCourse) {
                 alert("Editing entries for saved Short Course races is not directly supported via this button. Manage boats in the 'Next Race Pool' on the Race Entry tab before creating races.");
                 return;
            }
            const raceForEdit = seriesForEdit.races.find(r => r.raceNumber === raceNum); if (!raceForEdit) { alert("Race not found."); return; }
            // Load entries (prefer saved entries, fallback to deriving from results)
            entries = (raceForEdit.entries && raceForEdit.entries.length > 0)
                ? JSON.parse(JSON.stringify(raceForEdit.entries))
                : (raceForEdit.results && raceForEdit.results.length > 0)
                    ? raceForEdit.results.map(res => ({ sailNumber: res.sailNumber, boatClass: res.boatClass, skipper: res.skipper, yardstick: res.yardstick, status: res.status, elapsedTime: res.elapsedTime || '' }))
                    : [];
            setActiveTab(raceTab);
            switchToStandardRaceUI(); // Ensure standard UI is shown
            if(selectSeries) selectSeries.value = seriesId; updateRaceDropdown(); if(selectRace) selectRace.value = raceNumStr;
            renderEntriesTable(); editMode = true;
            if(editModeWarning) { editModeWarning.textContent = `Editing Mode: Loaded saved entries for Race ${raceNum}. Modify entries, then use 'Calculate Race Results & View' and 'Save These Results' on the Results tab.`; editModeWarning.classList.remove('hidden'); }
            disableDirectEditMode(); clearEntryForm();
        });

        if(editResultsDirectlyBtn) editResultsDirectlyBtn.addEventListener('click', () => { /* ... remains unchanged ... */ if (!results || results.length === 0) { alert("No results loaded to edit directly."); return; } if (directEditMode) disableDirectEditMode(); else enableDirectEditMode(); });
        function enableDirectEditMode() { /* ... remains unchanged ... */
             directEditMode = true;
             if(directEditWarning) { directEditWarning.innerHTML = `<strong>Direct Edit Mode Active:</strong> Manually edit positions, points, status, or time below. Use 'Update Displayed Result' then 'Save These Results to Series'. Recalculating will revert direct edits.`; directEditWarning.classList.remove('hidden'); }
             if(editResultsDirectlyBtn) { editResultsDirectlyBtn.textContent = 'Cancel Direct Edit'; editResultsDirectlyBtn.classList.add('btn-danger'); editResultsDirectlyBtn.classList.remove('btn-warning'); }
             renderRaceResults(); if(editResultForm) editResultForm.classList.add('hidden');
         }
        function disableDirectEditMode() { /* ... remains unchanged ... */
             directEditMode = false;
             if(directEditWarning) directEditWarning.classList.add('hidden');
             if(editResultsDirectlyBtn) { editResultsDirectlyBtn.textContent = 'Direct Edit'; editResultsDirectlyBtn.classList.remove('btn-danger'); editResultsDirectlyBtn.classList.add('btn-warning'); }
             if(editResultForm) editResultForm.classList.add('hidden');
             renderRaceResults(); resultsBody?.querySelectorAll('.edit-result-btn').forEach(btn => btn.classList.add('hidden')); resultsBody?.querySelectorAll('tr.result-highlight').forEach(row => row.classList.remove('result-highlight'));
         }
        function showEditResultDialog(index) { /* ... remains unchanged ... */
            if (!directEditMode || index < 0 || index >= results.length) return;
            const result = results[index]; resultBeingEdited = JSON.parse(JSON.stringify(result));
            if(editResultLabel) editResultLabel.textContent = `${result.sailNumber} - ${result.skipper} (${result.boatClass})`;
            if(editStatusDirect) editStatusDirect.value = result.status;
            if(editElapsedTimeDirect) editElapsedTimeDirect.value = result.elapsedTime || '';
            if(editPositionDirect) editPositionDirect.value = result.position ?? '';
            if(editPointsDirect) editPointsDirect.value = result.points ?? '';
            if(editResultIndex) editResultIndex.value = index;
            if(editTimeInputsDirect) editTimeInputsDirect.style.display = (editStatusDirect?.value === 'finished') ? 'block' : 'none';
            if(editResultForm) { editResultForm.classList.remove('hidden'); editResultForm.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }
        if(editStatusDirect) editStatusDirect.addEventListener('change', () => { /* ... remains unchanged ... */ if(editTimeInputsDirect) editTimeInputsDirect.style.display = (editStatusDirect.value === 'finished') ? 'block' : 'none'; if (editStatusDirect.value !== 'finished' && editElapsedTimeDirect) editElapsedTimeDirect.value = ''; });
        if(saveEditResult) saveEditResult.addEventListener('click', () => { /* ... remains unchanged ... */
             const index = parseInt(editResultIndex?.value); if (isNaN(index) || index < 0 || index >= results.length) { alert('Error saving edit: Invalid index.'); return; }
             const status = editStatusDirect?.value; const elapsed = editElapsedTimeDirect?.value.trim(); let positionInput = editPositionDirect?.value.trim(); const pointsInput = editPointsDirect?.value.trim();
             if(!status) { alert("Status is required."); return; } if(!positionInput) { alert("Position (or status code) is required."); return;} if(!pointsInput) { alert("Points are required."); return;}
             const points = parseFloat(pointsInput); if (isNaN(points)) { alert('Valid number for Points required.'); return; }
             if (status === 'finished' && !elapsed) { alert('Elapsed time (hh:mm:ss) required for Finished status in direct edit.'); return; } if (status === 'finished' && elapsed && !isValidTimeFormat(elapsed)) { alert('Valid elapsed time (hh:mm:ss) required, or change status.'); return; }
             let position; const positionNum = parseInt(positionInput);
             if (!isNaN(positionNum) && String(positionNum) === positionInput) { position = positionNum; }
             else { const allowedCodes = ['DNF', 'DNS', 'OCS', 'DSQ', 'OOD']; if (allowedCodes.includes(positionInput.toUpperCase())) { position = positionInput.toUpperCase(); } else { if (status !== 'finished') position = status.toUpperCase(); else { alert(`Invalid Position value "${positionInput}" for Finished status. Enter a number.`); return; } } }
             results[index].status = status; results[index].elapsedTime = (status === 'finished') ? elapsed : ''; results[index].position = position; results[index].points = points;
             if (status === 'finished' && elapsed) { const tempElapsedSeconds = timeToSeconds(elapsed); const tempCorrectedSeconds = tempElapsedSeconds * 100 / results[index].yardstick; results[index].correctedTime = secondsToTime(tempCorrectedSeconds); results[index].correctedSeconds = tempCorrectedSeconds; }
             else { results[index].correctedTime = null; results[index].correctedSeconds = null; }
             if(editResultForm) editResultForm.classList.add('hidden'); renderRaceResults();
             if(directEditWarning) { directEditWarning.innerHTML = `<strong>Direct Edit Mode Active:</strong> Result display updated. Click 'Save These Results' to make changes permanent. Recalculating will revert direct edits.`; directEditWarning.classList.remove('hidden'); }
             console.log(`Result for index ${index} display updated (direct edit).`);
         });
        if(cancelEditResult) cancelEditResult.addEventListener('click', () => { /* ... remains unchanged ... */ if(editResultForm) editResultForm.classList.add('hidden'); resultBeingEdited = null; });


        // --- Series Management (MODIFIED for Short Course) ---
        // Toggle standard series options based on short course checkbox
        if (seriesShortCourseCheck) seriesShortCourseCheck.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            if (standardSeriesOptions) standardSeriesOptions.classList.toggle('hidden', isChecked);
        });

        if(createSeriesBtn) createSeriesBtn.addEventListener('click', () => {
            if(seriesName) seriesName.value = '';
            if(seriesShortCourseCheck) seriesShortCourseCheck.checked = false; // Default to standard
            if(standardSeriesOptions) standardSeriesOptions.classList.remove('hidden'); // Show standard options
            if(numberOfRaces) numberOfRaces.value = '8';
            if(racesPerDiscardInput) racesPerDiscardInput.value = '4';
            if(editSeriesId) editSeriesId.value = '';
            const defaultDncRadio = document.getElementById('dnc-rule-race');
            if(defaultDncRadio) defaultDncRadio.checked = true;
            if(createSeriesForm) createSeriesForm.classList.remove('hidden'); // Use hidden class
        });

        if(saveSeriesBtn) saveSeriesBtn.addEventListener('click', () => {
            console.log("Attempting to save series..."); // Logging
            const name = seriesName?.value.trim();
            const isShortCourse = seriesShortCourseCheck?.checked || false;
            let races = parseInt(numberOfRaces?.value); // Read initially
            let discardThreshold = parseInt(racesPerDiscardInput?.value); // Read initially
            const editId = editSeriesId?.value;
            const dncRuleInput = document.querySelector('input[name="dnc-scoring-rule"]:checked');
            const dncScoringRule = dncRuleInput ? dncRuleInput.value : 'raceEntries';

            if (!name) { alert('Series Name required.'); return; }

            // --- Short Course Specific Adjustments ---
            if (isShortCourse) {
                discardThreshold = 0; // Force no discards for short course
                // races = 0; // Let numberOfRaces reflect actual saved count later
                console.log("Saving as Short Course, discards set to 0."); // Logging
            } else {
                // --- Standard Series Validation ---
                if (isNaN(races) || isNaN(discardThreshold)) { alert('Number of Races and Races Per Discard required for standard series.'); return; }
                if (races < 1 || races > 50) { alert('Number of races must be 1-50.'); return; }
                if (discardThreshold < 0 || discardThreshold > 20 ) { alert(`'Races Per Discard' must be between 0 and 20. (0 means no discards).`); return; }
                console.log(`Saving as Standard Course. Planned Races: ${races}, Discard Threshold: ${discardThreshold}`); // Logging
            }

            if (editId) { // Editing existing series
                const seriesIndex = series.findIndex(s => s.id === parseInt(editId));
                if (seriesIndex !== -1) {
                    console.log("Updating existing series:", name, "ID:", editId); // Logging
                    const existingSeries = series[seriesIndex];
                    const wasShortCourse = existingSeries.isShortCourse;
                    existingSeries.name = name;
                    existingSeries.isShortCourse = isShortCourse; // Update type
                    existingSeries.dncScoringRule = dncScoringRule;
                    existingSeries.discardThreshold = discardThreshold; // Use adjusted value

                    if (isShortCourse) {
                         // If switching TO short course, numberOfRaces will now reflect actual saved races
                         existingSeries.numberOfRaces = existingSeries.races.length;
                         console.log(`Series ${name} updated to Short Course. numberOfRaces set to ${existingSeries.numberOfRaces}.`);
                    } else {
                        // Updating a standard series (or switching FROM short course)
                        const oldNumRaces = existingSeries.numberOfRaces; // Previous planned number
                        existingSeries.numberOfRaces = races; // Set the new planned number

                        // Adjust races array if needed
                         if (races > existingSeries.races.length) { // Need to add race placeholders
                            const start = existingSeries.races.length + 1;
                            for (let i = start; i <= races; i++) { existingSeries.races.push({ raceNumber: i, date: null, entries: [], results: [] }); }
                            console.log(`Added ${races - (start - 1)} race placeholders.`); // Logging
                        } else if (races < existingSeries.races.length) { // Need to remove races
                             const racesToRemove = existingSeries.races.slice(races);
                             const hasResultsInRemoved = racesToRemove.some(r => r.results && r.results.length > 0);
                             if (hasResultsInRemoved && !confirm(`Reducing races removes races ${races + 1}-${existingSeries.races.length} and their results. Continue?`)) {
                                 // User cancelled removal, revert planned number in UI and data?
                                 if (numberOfRaces) numberOfRaces.value = existingSeries.races.length; // Revert UI input
                                 existingSeries.numberOfRaces = existingSeries.races.length; // Revert data
                                 console.log("Race removal cancelled by user."); // Logging
                                 return; // Stop the save process
                             }
                             console.log(`Removing ${existingSeries.races.length - races} races.`); // Logging
                             existingSeries.races = existingSeries.races.slice(0, races);
                         }
                        console.log(`Series ${name} updated as Standard Course. Planned races: ${races}`);
                    }
                    alert(`Series "${name}" updated.`);
                } else {
                     alert("Error finding series to update.");
                     console.error("Could not find series with ID", editId, "to update."); // Logging
                     return;
                }
            } else { // Creating new series
                 console.log("Creating new series:", name); // Logging
                 const newSeries = {
                     id: Date.now(),
                     name,
                     isShortCourse: isShortCourse,
                     numberOfRaces: isShortCourse ? 0 : races, // Start with 0 for short course, planned for standard
                     discardThreshold: discardThreshold, // Use adjusted value
                     dncScoringRule: dncScoringRule,
                     races: [] // Start empty, populate for standard
                 };
                 if (!isShortCourse) {
                     for (let i = 1; i <= races; i++) { newSeries.races.push({ raceNumber: i, date: null, entries: [], results: [] }); }
                 }
                 series.push(newSeries);
                 alert(`Series "${name}" (${isShortCourse ? 'Short Course' : 'Standard'}) created.`);
            }

            console.log("Series array length:", series.length); // Logging
            console.log("Saving series data to storage..."); // Logging
            saveSeriesToStorage();
            refreshSeriesList();
            refreshSeriesDropdowns();
            if(createSeriesForm) createSeriesForm.classList.add('hidden'); // Use hidden class
        });

        if(cancelSeriesBtn) cancelSeriesBtn.addEventListener('click', () => { if(createSeriesForm) createSeriesForm.classList.add('hidden'); }); // Use hidden class

        function refreshSeriesList() { /* ... MODIFIED to show type and handle short course details ... */
            if (!seriesList) return;
            seriesList.innerHTML = ''; if (series.length === 0) { seriesList.innerHTML = '<p>No series defined. Create one first.</p>'; return; }
            series.forEach(s => {
                const seriesCard = document.createElement('div'); seriesCard.classList.add('race-card');
                const racesWithResults = s.races.filter(race => race.results && race.results.length > 0).length;
                let dncRuleText = '';
                const rule = s.dncScoringRule || 'raceEntries';
                if (rule === 'raceEntries') dncRuleText = 'Race Entries + 1'; else dncRuleText = 'Series Competitors + 1';

                let detailsHTML = '';
                const seriesType = s.isShortCourse ? 'Short Course' : 'Standard';
                if (s.isShortCourse) {
                     // For short course, show number of saved races
                     detailsHTML = `<p><strong>Type:</strong> ${seriesType}</p>
                                   <p><strong>Races Saved:</strong> ${s.races.length}</p>`;
                } else {
                    // For standard, show planned vs completed and discard rule
                    const discardThreshold = s.discardThreshold ?? 0;
                    const discardRuleText = discardThreshold > 0 ? `1 discard per ${discardThreshold} completed races` : 'No discards';
                     detailsHTML = `<p><strong>Type:</strong> ${seriesType}</p>
                                    <p><strong>Races Planned:</strong> ${s.numberOfRaces} (${racesWithResults} completed)</p>
                                    <p><strong>Discard Rule:</strong> ${discardRuleText}</p>`;
                }

                seriesCard.innerHTML = `
                    <div class="race-info"><h3>${s.name}</h3></div>
                    ${detailsHTML}
                    <p><strong>DNC Scoring Rule:</strong> ${dncRuleText}</p>
                    <div class="race-actions">
                        <button class="btn-edit" onclick="editSeries(${s.id})">Edit Details</button>
                        <button class="btn-danger" onclick="deleteSeries(${s.id})">Delete Series</button>
                    </div>`;
                seriesList.appendChild(seriesCard);
            });
        }

        function editSeries(id) { /* ... MODIFIED to handle short course checkbox and use hidden class ... */
            const s = series.find(s => s.id === id); if (!s) return;
            if(seriesName) seriesName.value = s.name;
            if(seriesShortCourseCheck) seriesShortCourseCheck.checked = s.isShortCourse || false;
            // Use hidden class based on loaded type
            if(standardSeriesOptions) standardSeriesOptions.classList.toggle('hidden', s.isShortCourse);

            if (!s.isShortCourse) { // Populate standard fields only if it's standard
                 if(numberOfRaces) numberOfRaces.value = s.numberOfRaces;
                 if(racesPerDiscardInput) racesPerDiscardInput.value = s.discardThreshold ?? 0;
            } else { // Clear standard fields if short course (or set defaults if needed)
                 if(numberOfRaces) numberOfRaces.value = '8'; // Or maybe s.races.length? Default seems safer.
                 if(racesPerDiscardInput) racesPerDiscardInput.value = '4'; // Default
            }

            if(editSeriesId) editSeriesId.value = s.id;
            const currentDncRule = s.dncScoringRule || 'raceEntries';
            const dncRadioToSelect = document.getElementById(`dnc-rule-${currentDncRule === 'seriesCompetitors' ? 'series' : 'race'}`);
            if (dncRadioToSelect) dncRadioToSelect.checked = true;
            else { const defaultDncRadio = document.getElementById('dnc-rule-race'); if(defaultDncRadio) defaultDncRadio.checked = true; }

            if(createSeriesForm) {
                createSeriesForm.classList.remove('hidden'); // Use hidden class
                createSeriesForm.scrollIntoView({ behavior: 'smooth' });
            }
        }

        function deleteSeries(id) { /* ... remains unchanged ... */
            const seriesIndex = series.findIndex(s => s.id === id); if (seriesIndex === -1) return; const s = series[seriesIndex];
            if (confirm(`DELETE Series "${s.name}" and ALL its data permanently? Cannot be undone.`)) {
                series.splice(seriesIndex, 1); saveSeriesToStorage(); refreshSeriesList(); refreshSeriesDropdowns();
                // Clear selections if the deleted series was selected
                if (selectSeries?.value == id) selectSeries.value = "";
                if (resultsSeries?.value == id) { resultsSeries.value = ""; loadRaceResults(); }
                if (viewSeries?.value == id) { viewSeries.value = ""; calculateSeriesResults(); }
                if (viewAllSeries?.value == id) { viewAllSeries.value = ""; displayRaceViewer();}
                // Clear state if the deleted series was active
                if (currentSeries && currentSeries.id === id) {
                    currentSeries = null; currentRace = null; entries = []; results = []; shortCourseSessionRaces = [];
                    if(raceTab?.classList.contains('active-tab')) updateRaceEntryUI(); // Refresh UI based on no selection
                    if(resultsTab?.classList.contains('active-tab')) renderRaceResults();
                }
                alert(`Series "${s.name}" deleted.`);
            }
        }

        // --- Dropdown and State Management (MODIFIED for Short Course) ---
        function refreshSeriesDropdowns() { /* ... remains unchanged ... */
             const dropdowns = [selectSeries, resultsSeries, viewSeries, viewAllSeries];
             dropdowns.forEach((dropdown) => {
                 if (!dropdown) return; const selectedVal = dropdown.value; dropdown.innerHTML = '<option value="">Select Series</option>';
                 series.sort((a, b) => a.name.localeCompare(b.name));
                 series.forEach(s => { const option = document.createElement('option'); option.value = s.id; option.textContent = s.name + (s.isShortCourse ? ' (Short Course)' : ''); dropdown.appendChild(option); }); // Add type indicator
                 if (selectedVal && series.some(s => s.id == selectedVal)) dropdown.value = selectedVal; else dropdown.value = "";
             });
             // Trigger updates for dependent dropdowns/UI after a short delay
             setTimeout(() => {
                updateRaceEntryUI(); // Central function to handle Race Entry UI updates
                if (resultsSeries?.value) updateResultsRaceDropdown(); else if (resultsRace) { resultsRace.innerHTML = ''; loadRaceResults(); }
             }, 0);
         }

         // Central function to update the Race Entry tab UI based on selected series type
         function updateRaceEntryUI() {
             const seriesId = selectSeries?.value;
             if (!seriesId) {
                 currentSeries = null;
                 currentRace = null; // Ensure race is also cleared
                 switchToStandardRaceUI(); // Default UI when no series selected
                 selectRace.innerHTML = ''; // Clear race dropdown
                 entries = [];
                 renderEntriesTable(); // Render empty standard table
                 clearEntryForm();
                 clearShortCourseSessionData(); // Also clear any short course session
                 return;
             }

             currentSeries = series.find(s => s.id === parseInt(seriesId));
             if (!currentSeries) {
                 console.error("Selected series not found!");
                 currentSeries = null; // Reset
                 currentRace = null;
                 switchToStandardRaceUI();
                 selectRace.innerHTML = '';
                 entries = [];
                 renderEntriesTable();
                 clearEntryForm();
                 clearShortCourseSessionData();
                 return;
             }

             // Clear previous state regardless of type switch
             entries = [];
             clearShortCourseSessionData();
             editMode = false;
             editModeWarning?.classList.add('hidden');
             clearEntryForm();


             if (currentSeries.isShortCourse) {
                 console.log("Switching to Short Course UI for:", currentSeries.name);
                 switchToShortCourseUI();
                 renderShortCoursePoolTable(); // Render the empty pool
             } else {
                 console.log("Switching to Standard Race UI for:", currentSeries.name);
                 switchToStandardRaceUI();
                 updateRaceDropdown(); // Populate and handle standard race selection (will trigger updateRaceInfoAndEntries)
             }
         }

         // Helper to configure UI for Standard Races
         function switchToStandardRaceUI() {
             if (raceSelectorWrapper) raceSelectorWrapper.classList.remove('hidden');
             if (standardEntryFields) standardEntryFields.classList.remove('hidden');
             if (standardEntriesDisplay) standardEntriesDisplay.classList.remove('hidden');
             if (shortCourseStagingDisplay) shortCourseStagingDisplay.classList.add('hidden');
             if (shortCourseRacesContainer) shortCourseRacesContainer.classList.add('hidden');
             if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.classList.add('hidden');
             if (entryFormTitle) entryFormTitle.textContent = "Add/Edit Boat Entry";
             if (addBoatBtn) addBoatBtn.textContent = "Add Boat to Race";
             if (clearAllBtn) clearAllBtn.textContent = "Clear All Current Entries";
             // Update currentRace based on dropdown only if the dropdown exists and has a value
             currentRace = (selectRace && selectRace.value) ? parseInt(selectRace.value) : null;
             handleStatusChange(); // Ensure time input visibility is correct
         }

         // Helper to configure UI for Short Courses
         function switchToShortCourseUI() {
             if (raceSelectorWrapper) raceSelectorWrapper.classList.add('hidden');
             if (standardEntryFields) standardEntryFields.classList.add('hidden');
             if (standardEntriesDisplay) standardEntriesDisplay.classList.add('hidden');
             if (shortCourseStagingDisplay) shortCourseStagingDisplay.classList.remove('hidden');
             if (shortCourseRacesContainer) shortCourseRacesContainer.classList.remove('hidden'); // Show container, even if empty initially
             if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.classList.remove('hidden');
             if (entryFormTitle) entryFormTitle.textContent = "Add/Edit Boat for Pool";
             if (addBoatBtn) addBoatBtn.textContent = "Add Boat to Pool";
             if (clearAllBtn) clearAllBtn.textContent = "Clear Current Pool";
             if (selectRace) selectRace.innerHTML = ''; // Clear standard race dropdown
             currentRace = null; // No specific race number selected for short course pool
             renderShortCourseSessionRaces(); // Render any existing session races
             updateCreateRaceButton(); // Set initial button text
         }


        // Populate standard race dropdown (only called when series is standard)
        function updateRaceDropdown() {
            if (!selectRace || !currentSeries || currentSeries.isShortCourse) {
                 if (selectRace) selectRace.innerHTML = ''; // Clear if not applicable
                 updateRaceInfoAndEntries(); // Update based on no race selected
                 return;
            }
            const selectedRaceVal = selectRace.value;
            selectRace.innerHTML = ''; // Clear existing options

            populateRaceOptions(selectRace, currentSeries, true); // Use helper

            // Try to re-select previous or default to first
            if (selectedRaceVal && currentSeries.races.some(r => r.raceNumber == selectedRaceVal)) {
                selectRace.value = selectedRaceVal;
            } else if (currentSeries.races.length > 0 && currentSeries.races[0].raceNumber) {
                 // Default to the *first* race number in the sorted array
                 const firstRaceNum = currentSeries.races.sort((a,b) => a.raceNumber - b.raceNumber)[0].raceNumber;
                 selectRace.value = String(firstRaceNum);
            } else {
                 // No races exist yet, leave dropdown empty or with placeholder?
                 selectRace.innerHTML = '<option value="">No races</option>';
                 selectRace.disabled = true;
            }
            updateRaceInfoAndEntries(); // Load data for the selected standard race
        }

        function updateResultsRaceDropdown(loadResultsAfterUpdate = true) { /* ... remains unchanged ... */
            if (!resultsRace || !resultsSeries) return; const selectedRaceVal = resultsRace.value; resultsRace.innerHTML = '';
            const seriesId = resultsSeries.value; const selectedSeriesForDropdown = series.find(s => s.id === parseInt(seriesId));
            if (!selectedSeriesForDropdown) { currentSeries = null; currentRace = null; if (loadResultsAfterUpdate) { results = []; renderRaceResults(); } return; }
            populateRaceOptions(resultsRace, selectedSeriesForDropdown, true);
            let defaultRaceVal = null;
            if (selectedRaceVal && selectedSeriesForDropdown.races.some(r => r.raceNumber == selectedRaceVal)) { defaultRaceVal = selectedRaceVal; }
            else if (selectedSeriesForDropdown.races.length > 0) { let lastRaceWithResults = -1; for(let i = selectedSeriesForDropdown.races.length - 1; i >= 0; i--){ if(selectedSeriesForDropdown.races[i].results && selectedSeriesForDropdown.races[i].results.length > 0){ lastRaceWithResults = selectedSeriesForDropdown.races[i].raceNumber; break; } } defaultRaceVal = (lastRaceWithResults !== -1) ? lastRaceWithResults.toString() : (selectedSeriesForDropdown.races[0]?.raceNumber?.toString() || null); } // Default to last saved or first race
            if (defaultRaceVal) resultsRace.value = defaultRaceVal;
            if (loadResultsAfterUpdate) { currentSeries = selectedSeriesForDropdown; currentRace = defaultRaceVal ? parseInt(defaultRaceVal) : null; loadRaceResults(); }
            else { if(defaultRaceVal) { currentSeries = selectedSeriesForDropdown; currentRace = parseInt(defaultRaceVal); } else { currentSeries = null; currentRace = null; } }
        }
        function populateRaceOptions(dropdown, seriesData, showDetails) { /* ... remains unchanged ... */
            if (!dropdown || !seriesData || !seriesData.races) return; dropdown.innerHTML = '';
            // Sort races by raceNumber before populating
            const sortedRaces = [...seriesData.races].sort((a,b) => a.raceNumber - b.raceNumber);

            // Determine the maximum race number to show (either planned or actual saved)
            const maxRaceNumToShow = seriesData.isShortCourse
                ? (sortedRaces.length > 0 ? Math.max(...sortedRaces.map(r => r.raceNumber)) : 0) // Max saved for short course
                : seriesData.numberOfRaces; // Planned for standard

            if (maxRaceNumToShow === 0 && sortedRaces.length === 0) { // Handle empty series
                 dropdown.innerHTML = '<option value="">No races</option>';
                 dropdown.disabled = true;
                 return;
            }
             dropdown.disabled = false;

            for (let i = 1; i <= maxRaceNumToShow; i++) {
                const option = document.createElement('option'); option.value = i; let text = `Race ${i}`;
                const race = sortedRaces.find(r => r.raceNumber === i); // Find race data using the loop index
                if (showDetails && race) {
                    const hasResults = race.results && race.results.length > 0; let details = [];
                    if (hasResults) details.push("Saved");
                    if (race.date) { try { details.push(new Date(race.date + 'T00:00:00').toLocaleDateString('en-AU', {day:'numeric', month:'short'})); } catch (e) { console.error("Date format error", e)} }
                    if (details.length > 0) text += ` (${details.join(', ')})`; else if (!seriesData.isShortCourse || (race.entries && race.entries.length > 0)) text += ` (Not Saved)`; // Show not saved for standard, or SC if entries exist but no results
                } else if (!race && !seriesData.isShortCourse) {
                     text += ` (Not Saved)`; // Indicate empty planned races for standard series
                } else if (!race && seriesData.isShortCourse) {
                     continue; // Don't show options for non-existent races in short course dropdowns
                }
                option.textContent = text; dropdown.appendChild(option);
            }
             if (dropdown.options.length === 0) { // Case where short course has 0 saved races
                 dropdown.innerHTML = '<option value="">No races</option>';
                 dropdown.disabled = true;
             }
        }

        // Load entries for the selected STANDARD race
        function updateRaceInfoAndEntries() {
             // This function now only applies to STANDARD series
             if (!currentSeries || currentSeries.isShortCourse) {
                 entries = []; // Clear entries if short course or no series
                 renderEntriesTable(); // Clear standard table
                 editMode = false; editModeWarning?.classList.add('hidden');
                 return;
             }

             const selectedRaceNum = selectRace?.value;
             if (!selectedRaceNum) {
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm();
                 currentRace = null; // Ensure currentRace is null if dropdown is empty
                 return;
             }
             currentRace = parseInt(selectedRaceNum);
             if (isNaN(currentRace)) {
                 console.error("Invalid race number selected");
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm();
                 currentRace = null;
                 return;
             }

             const race = currentSeries.races.find(r => r.raceNumber === currentRace);
             if (!race) {
                 console.warn(`Race ${currentRace} object not found in series ${currentSeries.name}. Treating as new.`);
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm(); return;
              }

             const hasSavedEntries = race.entries && race.entries.length > 0;
             const hasSavedResults = race.results && race.results.length > 0;

             // Logic for loading/clearing remains similar, but only for standard races
             if (hasSavedEntries || hasSavedResults) {
                 if (editMode && entries.length > 0) { // If already editing something else (different race)
                     if (!confirm(`You have unsaved entries/changes. Load saved data for Race ${currentRace}? (Discards current changes)`)) {
                         // User cancelled - revert dropdown? For now, just show warning
                         if(editModeWarning) { editModeWarning.textContent = `WARNING: Viewing Race ${currentRace}, but unsaved changes exist from previous selection. Calculate & Save before proceeding.`; editModeWarning.classList.remove('hidden'); }
                         // Attempt to re-select the *previous* race number if possible
                         // Revert selectRace value (this is tricky, need to store previous value)
                         // For now, just warn is sufficient.
                         return;
                     }
                 }
                 // Load saved data
                 console.log(`Loading data for Standard Race ${currentRace}`);
                 if (hasSavedEntries) { entries = JSON.parse(JSON.stringify(race.entries)); }
                 else { console.warn(`Race ${currentRace} has results but no saved entries. Deriving entries from results.`); entries = race.results.map(res => ({ sailNumber: res.sailNumber, boatClass: res.boatClass, skipper: res.skipper, yardstick: res.yardstick, status: res.status, elapsedTime: res.elapsedTime || '' })); }
                 renderEntriesTable(); clearEntryForm(); editMode = false; editModeWarning?.classList.add('hidden'); // Loaded saved, not in 'edit' mode anymore
             } else {
                 // Race has no saved data
                 if (editMode && entries.length > 0) { // If already editing something else
                     if (!confirm(`You have unsaved entries/changes. Clear list for Race ${currentRace}? (Discards current changes)`)) {
                         if(editModeWarning) { editModeWarning.textContent = `WARNING: Viewing Race ${currentRace}, but unsaved changes exist from previous selection. Calculate & Save before proceeding.`; editModeWarning.classList.remove('hidden'); }
                         return;
                     }
                 }
                 console.log(`Clearing entries for empty Standard Race ${currentRace}`);
                 entries = []; renderEntriesTable(); clearEntryForm(); editMode = false; editModeWarning?.classList.add('hidden');
             }
        }

        // Dropdown event listeners
        if(selectSeries) selectSeries.addEventListener('change', updateRaceEntryUI); // Central handler
        if(selectRace) selectRace.addEventListener('change', () => { // Only relevant for standard series
             if (currentSeries && !currentSeries.isShortCourse) { updateRaceInfoAndEntries(); }
        });
        if(resultsSeries) resultsSeries.addEventListener('change', () => updateResultsRaceDropdown(true));
        if(resultsRace) resultsRace.addEventListener('change', () => { const raceNum = parseInt(resultsRace.value); if (!isNaN(raceNum)) { currentRace = raceNum; loadRaceResults(); } else { currentRace = null; results = []; renderRaceResults(); } });
        if(viewSeries) viewSeries.addEventListener('change', calculateSeriesResults);
        if(viewAllSeries) viewAllSeries.addEventListener('change', displayRaceViewer);


        // --- Load Race Results (Results Tab) ---
        function loadRaceResults() { /* ... remains unchanged ... */
            currentSeries = series.find(s => s.id === parseInt(resultsSeries?.value)); currentRace = parseInt(resultsRace?.value);
            if (!currentSeries || isNaN(currentRace)) { // Check isNaN too
                 results = []; renderRaceResults(); disableDirectEditMode(); return;
            }
            const race = currentSeries.races.find(r => r.raceNumber === currentRace);
            if (!race || !race.results || race.results.length === 0) { results = []; renderRaceResults(); disableDirectEditMode(); return; }
            results = JSON.parse(JSON.stringify(race.results)); renderRaceResults(); disableDirectEditMode();
        }


        // --- Series Results Calculation ---
        function calculateSeriesResults() { /* ... MODIFIED to handle short course display & logic ... */
            const seriesId = viewSeries?.value;
            if (seriesResultsBody) seriesResultsBody.innerHTML = ''; if (seriesResultsHeader) seriesResultsHeader.innerHTML = '<tr><th>Loading...</th></tr>'; if (legendDiv) legendDiv.innerHTML = '<strong>Legend:</strong>';
            if (!seriesId) { if(seriesSummary) seriesSummary.innerHTML = '<p>Select a series.</p>'; if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; return; }
            const selectedSeries = series.find(s => s.id === parseInt(seriesId));
            if (!selectedSeries) { if(seriesSummary) seriesSummary.innerHTML = '<p>Error: Series not found.</p>'; if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; return; }

             const racesWithResults = selectedSeries.races.filter(r => r.results && r.results.length > 0);
             const completedRacesCount = racesWithResults.length;
             const totalRacesInSeries = selectedSeries.races.length; // Actual saved races

             // --- Discard Calculation (ONLY for standard series) ---
             let numDiscardsToApply = 0;
             let discardRuleText = 'None';
             if (!selectedSeries.isShortCourse) { // Only apply discards for standard series
                 const discardThreshold = selectedSeries.discardThreshold ?? 0;
                 if (discardThreshold > 0 && completedRacesCount > 0) {
                     numDiscardsToApply = Math.floor(completedRacesCount / discardThreshold);
                 }
                 discardRuleText = discardThreshold > 0 ? `1 per ${discardThreshold} completed races` : 'No discards';
             } else {
                 discardRuleText = 'N/A (Short Course)';
             }


            if (completedRacesCount === 0) {
                let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${selectedSeries.isShortCourse ? 'Short Course' : 'Standard'})</h3>`;
                if (selectedSeries.isShortCourse) {
                     summaryHTML += `<p><strong>Races Saved:</strong> ${totalRacesInSeries}</p>`;
                } else {
                    summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>`;
                }
                 summaryHTML += `<p><strong>Discard Rule:</strong> ${discardRuleText}</p><p style="color: orange; font-weight: bold;">No results saved yet.</p></div>`;
                 if(seriesSummary) seriesSummary.innerHTML = summaryHTML;
                 if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; if(seriesResultsBody) seriesResultsBody.innerHTML = '<tr><td colspan="6">No race results available.</td></tr>'; return;
             }

             // --- Render Summary ---
             let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${selectedSeries.isShortCourse ? 'Short Course' : 'Standard'})</h3>`;
             if (selectedSeries.isShortCourse) {
                 summaryHTML += `<p><strong>Races Completed/Saved:</strong> ${completedRacesCount}</p>`;
             } else {
                 summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>
                                <p><strong>Completed:</strong> ${completedRacesCount}</p>`;
             }
             summaryHTML += `<p><strong>Discard Rule:</strong> ${discardRuleText}</p>`;
             if (!selectedSeries.isShortCourse) { // Only show applied discards for standard
                 summaryHTML += `<p><strong>Discards Applied Now:</strong> ${numDiscardsToApply}</p>`;
             }
              summaryHTML += `</div>`;
              if(seriesSummary) seriesSummary.innerHTML = summaryHTML;


             // --- Prepare Header ---
             const raceNumbersInSeries = selectedSeries.races.map(r => r.raceNumber).sort((a, b) => a - b);
             if (raceNumbersInSeries.length === 0) {
                  if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; if(seriesResultsBody) seriesResultsBody.innerHTML = '<tr><td colspan="6">No races found.</td></tr>'; return;
             }
             let headerHTML = `<tr><th>Pos</th><th>Sail #</th><th>Skipper</th><th>Boat Class</th>`;
             raceNumbersInSeries.forEach(num => headerHTML += `<th>R${num}</th>`);
             headerHTML += `<th>Total</th><th>Net</th></tr>`;
             if(seriesResultsHeader) seriesResultsHeader.innerHTML = headerHTML;

             // --- Aggregate Competitor Data ---
             const competitors = new Map(); let allSailNumbers = new Set(); selectedSeries.races.forEach(r => { if(r.results) r.results.forEach(res => allSailNumbers.add(res.sailNumber)); });
             allSailNumbers.forEach(sailNo => {
                 if (!competitors.has(sailNo)) { let lastResult = null; for (let i = selectedSeries.races.length - 1; i >= 0; i--) { const r = selectedSeries.races[i]; if (r.results) { lastResult = r.results.find(res => res.sailNumber === sailNo); if (lastResult) break; } } competitors.set(sailNo, { sailNumber: sailNo, skipper: lastResult?.skipper || 'N/A', boatClass: lastResult?.boatClass || 'N/A', raceScores: new Map(), totalPoints: 0, netPoints: 0, position: 0 }); } // Use Map for scores { raceNum: { points, status, position, discarded } }
             });
             selectedSeries.races.forEach(race => { const raceNum = race.raceNumber; if (race.results && race.results.length > 0) { race.results.forEach(result => { const competitor = competitors.get(result.sailNumber); if(competitor) competitor.raceScores.set(raceNum, { points: result.points, status: result.status.toUpperCase(), position: result.position, discarded: false }); }); } });

             // --- Calculate Points, DNC, OOD, Discards, Net ---
             competitors.forEach(competitor => {
                  competitor.raceScores.forEach(score => { if (score) score.discarded = false; }); // Reset discards
                  const dncRule = selectedSeries.dncScoringRule || 'raceEntries';
                  const totalSeriesCompetitors = competitors.size;

                  // Fill in DNC/NR for races the competitor didn't have a result for
                  raceNumbersInSeries.forEach(raceNum => {
                      if (!competitor.raceScores.has(raceNum)) {
                          const correspondingRace = selectedSeries.races.find(r => r.raceNumber === raceNum);
                          if (correspondingRace && correspondingRace.results && correspondingRace.results.length > 0) { // Race happened, boat DNC
                              let dncPoints;
                              if (dncRule === 'raceEntries') { const numEntriesInRace = correspondingRace.results.length; dncPoints = numEntriesInRace + 1; }
                              else { dncPoints = totalSeriesCompetitors + 1; }
                              competitor.raceScores.set(raceNum, { points: dncPoints, status: 'DNC', position: 'DNC', discarded: false });
                          } else { // Race didn't happen or had no results
                              competitor.raceScores.set(raceNum, { points: null, status: 'NR', position: 'NR', discarded: false });
                          }
                      } else {
                          // Handle OOD points if necessary (use series context function)
                          const score = competitor.raceScores.get(raceNum);
                          if (score.status === 'OOD') {
                              score.points = calculateOODPointsSeriesContext(competitor.sailNumber, raceNum, selectedSeries, competitors);
                              competitor.raceScores.set(raceNum, score); // Update map with calculated points
                          }
                      }
                  });

                  const validScores = Array.from(competitor.raceScores.values()).filter(score => score && score.points !== null && !isNaN(score.points));
                  competitor.totalPoints = validScores.reduce((sum, score) => sum + score.points, 0);

                  // Apply discards ONLY for standard series
                  if (!selectedSeries.isShortCourse && validScores.length > 0 && numDiscardsToApply > 0) {
                      const scoresEligible = Array.from(competitor.raceScores.entries()) //[ [raceNum, scoreObj], ... ]
                          .filter(([rn, score]) => score && score.points !== null && !isNaN(score.points))
                          .map(([rn, score]) => ({ ...score, raceNumber: rn })) // Add raceNumber for sorting/tracking
                          .sort((a, b) => b.points - a.points); // Sort descending by points

                      for(let i = 0; i < Math.min(numDiscardsToApply, scoresEligible.length); i++){
                          const raceNumToDiscard = scoresEligible[i].raceNumber;
                          const scoreToDiscard = competitor.raceScores.get(raceNumToDiscard);
                          if (scoreToDiscard) scoreToDiscard.discarded = true;
                      }
                      competitor.netPoints = Array.from(competitor.raceScores.values())
                                                 .reduce((sum, score) => { if (score && score.points !== null && !isNaN(score.points) && !score.discarded) return sum + score.points; return sum; }, 0);
                  } else {
                      competitor.netPoints = competitor.totalPoints; // No discards for short course or if rule doesn't apply
                      competitor.raceScores.forEach(score => { if(score) score.discarded = false; }); // Ensure all marked non-discarded
                  }
              });


             // --- Sort Competitors ---
             const competitorsArray = Array.from(competitors.values());
             competitorsArray.sort((a, b) => { // Sort competitors
                 if (a.netPoints !== b.netPoints) return a.netPoints - b.netPoints; // Net points
                 // Tie-breaking: Last common race result
                 let lastCommonRaceResult = 0;
                 const sortedRaceNumbersDesc = [...raceNumbersInSeries].sort((x, y) => y - x);
                 for (const raceNum of sortedRaceNumbersDesc) {
                      const scoreA = a.raceScores.get(raceNum);
                      const scoreB = b.raceScores.get(raceNum);
                      // Ensure both scores exist and are not null/NaN before comparing
                      if (scoreA && scoreA.points != null && !isNaN(scoreA.points) && scoreB && scoreB.points != null && !isNaN(scoreB.points)) {
                          if (scoreA.points !== scoreB.points) {
                             lastCommonRaceResult = scoreA.points - scoreB.points;
                             break;
                          }
                      } else if (scoreA && scoreA.points != null && !isNaN(scoreA.points)) {
                          return -1; // A sailed, B didn't -> A is better (lower points)
                      } else if (scoreB && scoreB.points != null && !isNaN(scoreB.points)) {
                           return 1; // B sailed, A didn't -> B is better
                      }
                      // If both didn't sail or had null points, continue to next race
                 }
                 if (lastCommonRaceResult !== 0) return lastCommonRaceResult;

                 // Tie-breaking: Countback non-discarded scores (best to worst)
                 const scoresA = Array.from(a.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 const scoresB = Array.from(b.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 for (let i = 0; i < Math.min(scoresA.length, scoresB.length); i++) { if (scoresA[i] !== scoresB[i]) return scoresA[i] - scoresB[i]; }
                 // If still tied, the one with more counted races is better (fewer points per race average - implicitly handled by previous check)
                 // Or if countback exhausted, check who has fewer scores (more DNCs etc.)
                 if (scoresA.length !== scoresB.length) return scoresB.length - scoresA.length; // More races counted is better (fewer high DNC scores)

                 // Tie-breaking: Countback discarded scores (best to worst - optional, usually not needed)
                 // Only apply if discards were actually used (standard series)
                 if (!selectedSeries.isShortCourse && numDiscardsToApply > 0) {
                    const discardedA = Array.from(a.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    const discardedB = Array.from(b.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                     if (discardedA.length > 0 && discardedB.length > 0 && discardedA[0] !== discardedB[0]) return discardedA[0] - discardedB[0];
                 }

                 // Final tie-breaker: Sail number
                 return a.sailNumber.localeCompare(b.sailNumber, undefined, { numeric: true });
             });

             // --- Assign Positions ---
             let currentRank = 0; let currentPosition = 0;
             for (let i = 0; i < competitorsArray.length; i++) {
                 currentRank++;
                  // Check if tie broken with previous boat using the same complex logic
                 if (i === 0 || checkTieBrokenSeries(competitorsArray[i], competitorsArray[i-1], raceNumbersInSeries, selectedSeries.isShortCourse, numDiscardsToApply)) {
                     currentPosition = currentRank;
                 }
                 competitorsArray[i].position = currentPosition;
             }
             // Helper for tie-breaking check (used for position assignment)
             function checkTieBrokenSeries(boatA, boatB, raceNums, isShort, discardsApplied) {
                 if (boatA.netPoints !== boatB.netPoints) return true;
                 // Last common race
                 const sortedRaceNumbersDesc = [...raceNums].sort((x, y) => y - x);
                 for (const raceNum of sortedRaceNumbersDesc) { const scoreA = boatA.raceScores.get(raceNum); const scoreB = boatB.raceScores.get(raceNum); if (scoreA?.points != null && !isNaN(scoreA.points) && scoreB?.points != null && !isNaN(scoreB.points)) { if(scoreA.points !== scoreB.points) return true; } else if (scoreA?.points != null && !isNaN(scoreA.points)) return true; else if (scoreB?.points != null && !isNaN(scoreB.points)) return true; }
                 // Countback non-discarded
                 const scoresA = Array.from(boatA.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 const scoresB = Array.from(boatB.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 for (let i = 0; i < Math.min(scoresA.length, scoresB.length); i++) { if (scoresA[i] !== scoresB[i]) return true; }
                 if (scoresA.length !== scoresB.length) return true;
                 // Countback discarded (if applicable)
                 if (!isShort && discardsApplied > 0) {
                    const discardedA = Array.from(boatA.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    const discardedB = Array.from(boatB.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    if (discardedA.length > 0 && discardedB.length > 0 && discardedA[0] !== discardedB[0]) return true;
                 }
                 // Sail number
                 if (boatA.sailNumber.localeCompare(boatB.sailNumber, undefined, { numeric: true }) !== 0) return true;
                 return false; // Truly tied
              }

            // --- Render Table Body ---
            if(seriesResultsBody) {
                 seriesResultsBody.innerHTML = ''; if (competitorsArray.length === 0) { const row = seriesResultsBody.insertRow(); row.insertCell().textContent = 'No competitors found with results in this series.'; row.cells[0].colSpan = raceNumbersInSeries.length + 6; return; }
                 competitorsArray.forEach(competitor => {
                     const row = seriesResultsBody.insertRow();
                     let rowHTML = `<td>${competitor.position}</td><td>${competitor.sailNumber}</td><td>${competitor.skipper}</td><td>${competitor.boatClass}</td>`;
                     raceNumbersInSeries.forEach(raceNum => { // Iterate through the actual race numbers in header order
                         const score = competitor.raceScores.get(raceNum);
                         if (!score || score.status === 'NR') { rowHTML += `<td class="nr-cell" title="No Race / Not Sailed">NR</td>`; }
                         else {
                             const points = (score.points !== null && !isNaN(score.points)) ? score.points : '-'; const status = score.status.toUpperCase(); let cellContent = points;
                             // Append status only if it's not a number (e.g., DNF, DNS) or OOD? Or always show status for non-finishers?
                             // Let's show status code always if not 'FINISHED'
                             if (status !== 'FINISHED') cellContent = `${points}(${status})`;
                             const title = `title="${status} (Race Pos: ${score.position ?? status})"`;
                             rowHTML += `<td class="${score.discarded ? 'discarded' : ''}" ${title}>${cellContent}</td>`;
                         }
                     });
                     rowHTML += `<td>${competitor.totalPoints}</td><td><strong>${competitor.netPoints}</strong></td>`; row.innerHTML = rowHTML;
                 });
                 if (legendDiv) { legendDiv.innerHTML = `<strong>Legend:</strong> <span class="discarded-example">15</span> Discarded Score,&nbsp; <span class="nr-cell">NR</span> No Race/Not Sailed,&nbsp; <span>DNF</span> Did Not Finish,&nbsp; <span>DNS</span> Did Not Start,&nbsp; <span>OCS</span> On Course Side,&nbsp; <span>DSQ</span> Disqualified,&nbsp; <span>OOD</span> Race Officer Duty,&nbsp; <span>DNC</span> Did Not Compete (Race Sailed)`; }
             }
        }

        // Calculate OOD points using the series context (competitor map)
        function calculateOODPointsSeriesContext(sailNo, oodRaceNumber, seriesData, competitorMap) { /* ... MODIFIED to use Map ... */
             const competitor = competitorMap.get(sailNo); if (!competitor) return 0;
             let racePoints = []; let racesSailedCount = 0;

             // Get points from other races the competitor finished
             competitor.raceScores.forEach((score, raceNum) => {
                 if (raceNum !== oodRaceNumber && score && score.points !== null && !isNaN(score.points) && score.status === 'FINISHED') {
                     racePoints.push(score.points);
                     racesSailedCount++;
                 }
             });

             if (racesSailedCount > 0) {
                 const avgPoints = racePoints.reduce((sum, pts) => sum + pts, 0) / racesSailedCount;
                 return Math.round(avgPoints * 10) / 10;
             }
             else { // Fallback: average of finishers in the race they were OOD for
                 const oodRaceData = seriesData.races.find(r => r.raceNumber === oodRaceNumber);
                 let fallbackPoints = 0;
                 let finisherPointsInOODRace = [];
                 if (oodRaceData && oodRaceData.results) {
                      // Find points of all finishers in that race using the competitorMap for consistency
                      oodRaceData.results.forEach(result => {
                          if (result.status === 'finished') {
                               const finisherCompetitor = competitorMap.get(result.sailNumber);
                               const finisherScore = finisherCompetitor?.raceScores.get(oodRaceNumber);
                               if (finisherScore && finisherScore.points != null && !isNaN(finisherScore.points)) {
                                   finisherPointsInOODRace.push(finisherScore.points);
                               }
                          }
                      });
                 }

                 if (finisherPointsInOODRace.length > 0) {
                     const avgFinisherPoints = finisherPointsInOODRace.reduce((sum, r) => sum + r, 0) / finisherPointsInOODRace.length;
                     fallbackPoints = Math.round(avgFinisherPoints * 10) / 10;
                 } else {
                     fallbackPoints = 0; // No finishers in that race either
                 }
                 console.warn(`OOD Fallback used for ${sailNo} in Race ${oodRaceNumber}. Points: ${fallbackPoints}`);
                 return fallbackPoints;
             }
         }


        // --- Race Viewer Functions ---
        function displayRaceViewer() { /* ... MODIFIED for short course display ... */
            const seriesId = viewAllSeries?.value;
            if (raceSelector) raceSelector.innerHTML = ''; if (individualRaceInfo) individualRaceInfo.innerHTML = ''; if (individualRaceBody) individualRaceBody.innerHTML = ''; if (raceSummaryView) raceSummaryView.innerHTML = '';
            if (!seriesId) { if(raceSummaryView) raceSummaryView.innerHTML = '<p>Select a series.</p>'; return; }
            const selectedSeries = series.find(s => s.id === parseInt(seriesId)); if (!selectedSeries) { if(raceSummaryView) raceSummaryView.innerHTML = '<p>Error: Series not found.</p>'; return; }
            const completedRaces = selectedSeries.races.filter(r => r.results && r.results.length > 0).length;
            const totalRacesSaved = selectedSeries.races.length;
            const seriesType = selectedSeries.isShortCourse ? 'Short Course' : 'Standard';

             // --- Summary Panel ---
             let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${seriesType})</h3>`;
             if (selectedSeries.isShortCourse) {
                 summaryHTML += `<p><strong>Races Completed/Saved:</strong> ${totalRacesSaved}</p>`; // Use total saved for SC
             } else {
                 const discardThreshold = selectedSeries.discardThreshold ?? 0;
                 const discardRuleText = discardThreshold > 0 ? `1 discard per ${discardThreshold} completed races` : 'No discards';
                 summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>
                                <p><strong>Completed:</strong> ${completedRaces}</p>
                                <p><strong>Discard Rule:</strong> ${discardRuleText}</p>`;
             }
             summaryHTML += `</div>`;
             if(raceSummaryView) raceSummaryView.innerHTML = summaryHTML;

             // --- Race Buttons ---
             const raceNumbersToShow = selectedSeries.races.map(r => r.raceNumber).sort((a,b) => a - b);
             if (raceNumbersToShow.length === 0) {
                 if (raceSelector) raceSelector.innerHTML = '<p>No races saved in this series yet.</p>';
                 return;
             }

            let firstRaceWithResults = -1;
            if (raceSelector) {
                 raceNumbersToShow.forEach(raceNum => {
                    const raceBtn = document.createElement('button'); raceBtn.textContent = `Race ${raceNum}`; raceBtn.classList.add('race-button'); raceBtn.dataset.raceNumber = raceNum;
                    const race = selectedSeries.races.find(r => r.raceNumber === raceNum); const hasResults = race && race.results && race.results.length > 0;
                    if (hasResults) { raceBtn.classList.add('has-results'); if (firstRaceWithResults === -1) firstRaceWithResults = raceNum; if (race.date) { try { raceBtn.textContent += ` (${new Date(race.date + 'T00:00:00').toLocaleDateString('en-AU', {day:'numeric', month:'short'})})`; } catch (e) { console.error("Date format error", e)} } }
                    raceBtn.addEventListener('click', (e) => { document.querySelectorAll('.race-button.active').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); displayRaceResultsView(selectedSeries, raceNum); });
                    raceSelector.appendChild(raceBtn);
                 });
            }

             // --- Select Initial Race ---
            let lastRaceWithResults = -1;
             // Find the highest race number with results
             for(let i = selectedSeries.races.length - 1; i >= 0; i--){
                 const race = selectedSeries.races[i];
                 if(race && race.results && race.results.length > 0){
                     lastRaceWithResults = race.raceNumber; break;
                 }
             }
             // If no race has results, default to the first race number available
             const targetRaceNum = lastRaceWithResults !== -1 ? lastRaceWithResults : (raceNumbersToShow.length > 0 ? raceNumbersToShow[0] : null);

            if (targetRaceNum) { const targetButton = raceSelector?.querySelector(`.race-button[data-race-number="${targetRaceNum}"]`); if (targetButton) { targetButton.classList.add('active'); displayRaceResultsView(selectedSeries, targetRaceNum); } }
            else { if(individualRaceInfo) individualRaceInfo.innerHTML = '<p>Select a race button above.</p>'; }
        }

        function displayRaceResultsView(selectedSeriesData, raceNumber) { /* ... remains unchanged ... */
             if (!individualRaceBody || !individualRaceInfo || !selectedSeriesData) return; individualRaceBody.innerHTML = ''; individualRaceInfo.innerHTML = '';
             const race = selectedSeriesData.races.find(r => r.raceNumber === parseInt(raceNumber));
             if (!race || !race.results || race.results.length === 0) { individualRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race ${raceNumber} Results</h3><p>No results saved for this race.</p></div>`; const row = individualRaceBody.insertRow(); const cell = row.insertCell(); cell.colSpan = 9; cell.textContent = 'No results saved for this race.'; cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return; }
             const date = race.date ? new Date(race.date + 'T00:00:00').toLocaleDateString() : 'Not set';
             individualRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race ${race.raceNumber} Results</h3><p><strong>Date:</strong> ${date}</p><p><strong>Entries:</strong> ${race.results.length}</p></div>`;
             const sortedResults = [...race.results].sort((a, b) => { const posA = (typeof a.position === 'number') ? a.position : Infinity; const posB = (typeof b.position === 'number') ? b.position : Infinity; if(posA !== posB) return posA - posB; const pointsA = (a.points != null) ? a.points : Infinity; const pointsB = (b.points != null) ? b.points : Infinity; if (pointsA !== pointsB) return pointsA - pointsB; return a.sailNumber.localeCompare(b.sailNumber); });
             sortedResults.forEach(result => {
                 const row = individualRaceBody.insertRow();
                 row.innerHTML = `
                     <td>${result.position ?? '-'}</td><td>${result.sailNumber}</td><td>${result.boatClass}</td><td>${result.skipper}</td>
                     <td>${result.yardstick}</td><td>${result.status.toUpperCase()}</td><td>${result.elapsedTime || '-'}</td><td>${result.correctedTime || '-'}</td>
                     <td>${result.points ?? '-'}</td>`;
             });
         }


        // --- Local Storage ---
        // Version reflects both discardThreshold and shortCourse changes
        const SERIES_STORAGE_KEY = 'sailingSeriesData_v4_shortCourse';
        const BOATLIST_STORAGE_KEY = 'sailingBoatList_v1'; // No changes needed here

        function saveSeriesToStorage() { /* ... remains unchanged ... */
             try { localStorage.setItem(SERIES_STORAGE_KEY, JSON.stringify(series)); }
             catch (error) { console.error("Error saving series data:", error); alert("Could not save series data."); }
        }
        function loadSeriesFromStorage() { /* ... MODIFIED to handle short course flag & improve validation ... */
             const data = localStorage.getItem(SERIES_STORAGE_KEY);
             if (data) {
                 try {
                     let loadedSeries = JSON.parse(data);
                     if (!Array.isArray(loadedSeries)) { console.error("Loaded series data not array."); series = []; return; }
                     // Perform validation/migration on each series object
                     loadedSeries = loadedSeries.map((s, index) => {
                         // Basic structure
                         if (!s || typeof s !== 'object') { console.warn(`Invalid series data at index ${index}, skipping.`); return null; }
                         if (!s.id) s.id = Date.now() + index; // Assign ID if missing
                         if (!s.name) s.name = `Series ${s.id}`;
                         if (!s.races || !Array.isArray(s.races)) s.races = [];

                         // Short course flag
                         if (!s.hasOwnProperty('isShortCourse')) {
                             console.warn(`Series "${s.name}" missing isShortCourse flag. Defaulting to false (Standard).`);
                             s.isShortCourse = false;
                         }

                          // Discard threshold migration/validation
                          if (s.hasOwnProperty('discards') && !s.hasOwnProperty('discardThreshold')) {
                              console.warn(`Series "${s.name}" has old 'discards' property. Setting discardThreshold to 0.`);
                              s.discardThreshold = 0;
                              delete s.discards;
                          } else if (!s.hasOwnProperty('discardThreshold') || typeof s.discardThreshold !== 'number' || isNaN(s.discardThreshold) || s.discardThreshold < 0) {
                              s.discardThreshold = 0; // Ensure it exists and is valid, default to 0
                          }

                          // DNC Rule
                          if (!s.hasOwnProperty('dncScoringRule') || !['raceEntries', 'seriesCompetitors'].includes(s.dncScoringRule)) {
                               s.dncScoringRule = 'raceEntries';
                          }

                          // Number of Races & Race Array Structure (Important for Standard Series)
                          if (!s.isShortCourse) {
                             // Ensure numberOfRaces is a valid number
                             if (typeof s.numberOfRaces !== 'number' || isNaN(s.numberOfRaces) || s.numberOfRaces < 0) {
                                s.numberOfRaces = s.races.length > 0 ? Math.max(...s.races.map(r => r.raceNumber || 0), s.races.length) : 0; // Estimate based on existing races
                                console.warn(`Series "${s.name}" had invalid numberOfRaces. Set to ${s.numberOfRaces}.`);
                             }
                             const expectedNumRaces = s.numberOfRaces || 0;
                             // Reconcile race array if mismatch
                             if (s.races.length !== expectedNumRaces) {
                                 console.warn(`Fixing race structure for standard series "${s.name}". Expected ${expectedNumRaces}, found ${s.races.length}.`);
                                 let existingRacesData = new Map();
                                  // Use existing raceNumber as key if possible
                                 s.races.forEach((r, r_idx) => { if (r && r.raceNumber) existingRacesData.set(r.raceNumber, r); else if(r) existingRacesData.set(r_idx + 1, r); });
                                 s.races = [];
                                 for (let i = 1; i <= expectedNumRaces; i++) {
                                     const existing = existingRacesData.get(i);
                                     s.races.push({
                                         raceNumber: i,
                                         date: existing?.date || null,
                                         entries: existing?.entries && Array.isArray(existing.entries) ? existing.entries : [],
                                         results: existing?.results && Array.isArray(existing.results) ? existing.results : []
                                     });
                                 }
                             }
                          } else {
                             // For short course, numberOfRaces should reflect actual count
                             s.numberOfRaces = s.races.length;
                          }

                          // Ensure basic structure within races array elements
                          s.races = s.races.map((r, r_idx) => {
                             if (!r || typeof r !== 'object') { return { raceNumber: r_idx + 1, date: null, entries: [], results: [] }; } // Basic fallback
                             if (!r.hasOwnProperty('raceNumber') || typeof r.raceNumber !== 'number') r.raceNumber = r_idx + 1; // Assign if missing
                             if (!r.hasOwnProperty('entries') || !Array.isArray(r.entries)) r.entries = [];
                             if (!r.hasOwnProperty('results') || !Array.isArray(r.results)) r.results = [];
                             if (!r.hasOwnProperty('date')) r.date = null;
                             return r;
                          });

                         // Ensure races are sorted by raceNumber after potential fixes
                         s.races.sort((a, b) => (a.raceNumber || 0) - (b.raceNumber || 0));

                         return s;
                     }).filter(s => s !== null); // Remove any invalid series skipped during mapping

                     series = loadedSeries;
                 } catch (error) { console.error("Error parsing series data:", error); alert("Could not load series data. Starting fresh."); series = []; localStorage.removeItem(SERIES_STORAGE_KEY); }
             } else { series = []; }
         }

        function saveBoatListToStorage() { /* ... remains unchanged ... */
             try { localStorage.setItem(BOATLIST_STORAGE_KEY, JSON.stringify(boatList)); }
             catch (error) { console.error("Error saving boat list:", error); alert("Could not save boat list."); }
        }
        function loadBoatListFromStorage() { /* ... remains unchanged ... */
            const data = localStorage.getItem(BOATLIST_STORAGE_KEY);
            if (data) {
                try {
                    let loadedList = JSON.parse(data);
                    if (Array.isArray(loadedList)) {
                        const existingIds = new Set();
                        boatList = loadedList.map((b, index) => {
                            // Ensure basic structure and types
                            if (!b || typeof b !== 'object') return null; // Skip invalid entries
                            let id = b.id;
                             // Ensure ID is unique and valid type
                            if (!id || (typeof id !== 'number' && typeof id !== 'string') || existingIds.has(id)) {
                                 id = Date.now() + index + Math.random();
                                 console.warn(`Assigned new/unique ID to boat: ${b.sailNumber || `Index ${index}`}`);
                            }
                            existingIds.add(id);
                            const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`;
                            const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown';
                            const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown';
                            const yardstick = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                            // Ensure required fields have some value
                            if (!sailNumber || !boatClass || !skipper || yardstick <= 0) {
                                console.warn(`Imported boat missing data, assigning defaults: ID ${id}`);
                                // You might choose to skip instead: return null;
                            }
                            return { id, sailNumber, boatClass, skipper, yardstick };
                        }).filter(b => b !== null); // Filter out any null entries skipped
                    } else { boatList = []; }
                } catch (error) { console.error("Error parsing boat list data:", error); alert("Could not load saved boat list. Starting fresh."); boatList = []; localStorage.removeItem(BOATLIST_STORAGE_KEY); }
            } else { boatList = []; }
        }

        // --- Export Data Function ---
        function exportAllData() { /* ... MODIFIED version string ... */
            if (series.length === 0 && boatList.length === 0) { alert("No data (series or boats) available to export."); return; }
            try {
                const exportData = {
                    version: "LysterfieldResultsApp_v1.5_elapsedTimeFix", // Update version string
                    exportDate: new Date().toISOString(),
                    seriesData: series, // Contains isShortCourse flag
                    boatListData: boatList
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `lysterfield_results_backup_${dateStr}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                alert("Data exported successfully!");
            } catch (error) { console.error("Error during data export:", error); alert("An error occurred while exporting data."); }
        }

        // --- Import Data Function ---
        function importData(event) { /* ... Enhanced validation from load function ... */
            const file = event.target.files[0]; if (!file) return;
            if (!confirm("IMPORTING DATA WILL REPLACE ALL CURRENT SERIES AND BOAT LIST DATA. Are you absolutely sure?")) { importFileInput.value = null; return; }
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result; const parsedData = JSON.parse(fileContent);
                    if (!parsedData || typeof parsedData !== 'object' || !Array.isArray(parsedData.seriesData) || !Array.isArray(parsedData.boatListData)) { throw new Error("Invalid file format. Expected object with 'seriesData' and 'boatListData' arrays."); }
                    console.log("Importing data structure version:", parsedData.version || "Unknown");

                    // --- VALIDATION/MIGRATION on imported series ---
                    let importedSeries = parsedData.seriesData;
                     importedSeries = importedSeries.map((s, index) => {
                         // Basic structure check (copied from load function)
                         if (!s || typeof s !== 'object') { console.warn(`Invalid imported series data at index ${index}, skipping.`); return null; }
                         if (!s.id) s.id = Date.now() + index;
                         if (!s.name) s.name = `Series ${s.id}`;
                         if (!s.races || !Array.isArray(s.races)) s.races = [];
                         // Short course flag
                         if (!s.hasOwnProperty('isShortCourse')) { s.isShortCourse = false; }
                         // Discard threshold
                         if (s.hasOwnProperty('discards') && !s.hasOwnProperty('discardThreshold')) { s.discardThreshold = 0; delete s.discards; }
                         else if (!s.hasOwnProperty('discardThreshold') || typeof s.discardThreshold !== 'number' || isNaN(s.discardThreshold) || s.discardThreshold < 0) { s.discardThreshold = 0; }
                         // DNC Rule
                         if (!s.hasOwnProperty('dncScoringRule') || !['raceEntries', 'seriesCompetitors'].includes(s.dncScoringRule)) { s.dncScoringRule = 'raceEntries'; }
                         // Number of Races & Structure (standard series)
                         if (!s.isShortCourse) {
                            if (typeof s.numberOfRaces !== 'number' || isNaN(s.numberOfRaces) || s.numberOfRaces < 0) { s.numberOfRaces = s.races.length > 0 ? Math.max(...s.races.map(r => r.raceNumber || 0), s.races.length) : 0; }
                            const expectedNumRaces = s.numberOfRaces || 0;
                            if (s.races.length !== expectedNumRaces) {
                                let existingRacesData = new Map(); s.races.forEach((r, r_idx) => { if (r && r.raceNumber) existingRacesData.set(r.raceNumber, r); else if(r) existingRacesData.set(r_idx + 1, r); });
                                s.races = [];
                                for (let i = 1; i <= expectedNumRaces; i++) { const existing = existingRacesData.get(i); s.races.push({ raceNumber: i, date: existing?.date || null, entries: existing?.entries && Array.isArray(existing.entries) ? existing.entries : [], results: existing?.results && Array.isArray(existing.results) ? existing.results : [] }); }
                            }
                         } else { s.numberOfRaces = s.races.length; } // Correct count for short course
                         // Validate individual races
                         s.races = s.races.map((r, r_idx) => { if (!r || typeof r !== 'object') { return { raceNumber: r_idx + 1, date: null, entries: [], results: [] }; } if (!r.hasOwnProperty('raceNumber') || typeof r.raceNumber !== 'number') r.raceNumber = r_idx + 1; if (!r.hasOwnProperty('entries') || !Array.isArray(r.entries)) r.entries = []; if (!r.hasOwnProperty('results') || !Array.isArray(r.results)) r.results = []; if (!r.hasOwnProperty('date')) r.date = null; return r; });
                         s.races.sort((a, b) => (a.raceNumber || 0) - (b.raceNumber || 0));
                         return s;
                     }).filter(s => s !== null);

                     // --- VALIDATION/MIGRATION on imported boat list ---
                     let importedBoatList = parsedData.boatListData;
                     const existingIds = new Set();
                     importedBoatList = importedBoatList.map((b, index) => {
                         // Validation copied from load function
                         if (!b || typeof b !== 'object') return null;
                         let id = b.id; if (!id || (typeof id !== 'number' && typeof id !== 'string') || existingIds.has(id)) { id = Date.now() + index + Math.random(); }
                         existingIds.add(id); const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`; const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown'; const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown'; const yardstick = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                         if (!sailNumber || !boatClass || !skipper || yardstick <= 0) { console.warn(`Imported boat missing data, skipping: ID ${id}`); return null; }
                         return { id, sailNumber, boatClass, skipper, yardstick };
                     }).filter(b => b !== null);

                    // --- Replace current data and Save ---
                    series = importedSeries;
                    boatList = importedBoatList;
                    saveSeriesToStorage(); saveBoatListToStorage();

                    // --- Refresh UI and Reset State ---
                    refreshSeriesList(); refreshSeriesDropdowns(); renderBoatListTable(); populateSavedBoatDropdown();
                    entries = []; results = []; currentSeries = null; currentRace = null; shortCourseSessionRaces = [];
                    if(raceTab?.classList.contains('active-tab')) updateRaceEntryUI();
                    if(resultsTab?.classList.contains('active-tab')) renderRaceResults();
                    if(seriesResultsTab?.classList.contains('active-tab')) calculateSeriesResults();
                    if(raceViewTab?.classList.contains('active-tab')) displayRaceViewer();
                    setActiveTab(seriesTab); // Go back to series tab after import
                    alert("Data imported successfully! All previous data has been replaced.");
                } catch (error) { console.error("Error during data import:", error); alert("Error importing data: " + error.message + ". Data not changed."); }
                finally { importFileInput.value = null; }
            };
            reader.onerror = function() { alert("Error reading the selected file."); importFileInput.value = null; };
            reader.readAsText(file);
        }

        // --- Export Boat List Function ---
        function exportBoatList() { /* ... remains unchanged ... */
            if (boatList.length === 0) { alert("Boat list is empty. Nothing to export."); return; }
            try {
                const exportData = { version: "LysterfieldResultsApp_BoatList_v1.0", exportDate: new Date().toISOString(), boatListData: boatList };
                const jsonString = JSON.stringify(exportData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; const dateStr = new Date().toISOString().split('T')[0]; a.download = `lysterfield_boat_list_backup_${dateStr}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                alert("Boat list exported successfully!");
            } catch (error) { console.error("Error during boat list export:", error); alert("Error exporting boat list."); }
        }

        // --- Import Boat List Function ---
        function importBoatList(event) { /* ... Enhanced validation from load function ... */
            const file = event.target.files[0]; if (!file) return;
            if (!confirm("IMPORTING BOAT LIST WILL REPLACE YOUR CURRENT SAVED BOAT LIST. Series data will NOT be affected. Are you sure?")) { importBoatListFileInput.value = null; return; }
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result; let parsedData = JSON.parse(fileContent);
                    // Allow importing a direct array or the standard export format
                    let importedList;
                    if (Array.isArray(parsedData)) {
                        console.warn("Importing a direct array of boats.");
                        importedList = parsedData;
                    } else if (parsedData && typeof parsedData === 'object' && Array.isArray(parsedData.boatListData)) {
                        console.log("Importing boat list structure version:", parsedData.version || "Unknown");
                        importedList = parsedData.boatListData;
                    } else {
                        throw new Error("Invalid file format. Expected an array of boats or an object with a 'boatListData' array.");
                    }

                     const existingIds = new Set();
                     const validatedBoatList = importedList.map((b, index) => {
                         // Validation copied from load function
                         if (!b || typeof b !== 'object') return null;
                         let id = b.id; if (!id || (typeof id !== 'number' && typeof id !== 'string') || existingIds.has(id)) { id = Date.now() + index + Math.random(); }
                         existingIds.add(id); const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`; const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown'; const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown'; const yardstick = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                         if (!sailNumber || !boatClass || !skipper || yardstick <= 0) { console.warn(`Imported boat missing data, skipping: ID ${id}`); return null; }
                         return { id, sailNumber, boatClass, skipper, yardstick };
                     }).filter(b => b !== null);

                    boatList = validatedBoatList;
                    saveBoatListToStorage();
                    renderBoatListTable(); populateSavedBoatDropdown();
                    alert("Boat list imported successfully! Your previous boat list has been replaced.");
                } catch (error) { console.error("Error during boat list import:", error); alert("Error importing boat list: " + error.message + ". List not changed."); }
                finally { importBoatListFileInput.value = null; }
            };
            reader.onerror = function() { alert("Error reading the selected file."); importBoatListFileInput.value = null; };
            reader.readAsText(file);
        }

        // --- Initialization ---
        function initApp() {
            console.log("Initializing Sailing App v1.5_elapsedTimeFix..."); // Update version
            initYardsticks();
            loadBoatListFromStorage();
            loadSeriesFromStorage();
            refreshSeriesList();
            refreshSeriesDropdowns(); // This now triggers updateRaceEntryUI
            renderBoatListTable();
            setActiveTab(seriesTab); // Default to series tab

            // Attach Export/Import Listeners
            if (exportAllDataBtn) exportAllDataBtn.addEventListener('click', exportAllData);
            if (importDataBtn && importFileInput) { importDataBtn.addEventListener('click', () => importFileInput.click()); importFileInput.addEventListener('change', importData); }
            if (exportBoatListBtn) exportBoatListBtn.addEventListener('click', exportBoatList);
            if (importBoatListBtn && importBoatListFileInput) { importBoatListBtn.addEventListener('click', () => importBoatListFileInput.click()); importBoatListFileInput.addEventListener('change', importBoatList); }

            console.log("App Initialized.");
            console.log("Initial Series Data:", series); // Log initial data
            console.log("Initial Boat List:", boatList); // Log initial data
        }

        // Make functions globally accessible for onclick handlers/inline events
         window.editEntry = editEntry;
         window.removeEntry = removeEntry;
         window.editSeries = editSeries;
         window.deleteSeries = deleteSeries;
         window.showEditResultDialog = showEditResultDialog;
         window.editBoatInList = editBoatInList;
         window.deleteBoatFromList = deleteBoatFromList;
         window.editShortCourseEntry = editShortCourseEntry;
         window.removeShortCourseEntry = removeShortCourseEntry;
         window.updateShortCourseEntry = updateShortCourseEntry;

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>